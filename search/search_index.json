{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nzend-view provides the \"View\" layer of Zend Framework 2's MVC system. It is a\nmulti-tiered system allowing a variety of mechanisms for extension,\nsubstitution, and more.\n\n\nThe components of the view layer are as follows:\n\n\n\n\nVariables Containers\n hold variables and callbacks that you wish to\n  represent in the view.  Often-times, a Variables Container will also provide\n  mechanisms for context-specific escaping of variables and more.\n\n\nView Models\n hold Variables Containers, specify the template to use (if\n  any), and optionally provide rendering options (more on that below). View\n  Models may be nested in order to represent complex structures.\n\n\nRenderers\n take View Models and provide a representation of them to return.\n  zend-view ships with three renderers by default: a \nPhpRenderer\n which\n  utilizes PHP templates in order to generate markup, a \nJsonRenderer\n, and a\n  \nFeedRenderer\n for generating RSS and Atom feeds.\n\n\nResolvers\n utilize Resolver Strategies to resolve a template name to a\n  resource a Renderer may consume. As an example, a Resolver may take the name\n  \"blog/entry\" and resolve it to a PHP view script.\n\n\nThe \nView\n consists of strategies that map the current Request to a\n  Renderer, and strategies for injecting the result of rendering to the\n  Response.\n\n\nRendering Strategies\n listen to the \nZend\\View\\ViewEvent::EVENT_RENDERER\n\n  event of the View and decide which Renderer should be selected based on the\n  Request or other criteria.\n\n\nResponse Strategies\n are used to inject the Response object with the\n  results of rendering. That may also include taking actions such as setting\n  Content-Type headers.\n\n\n\n\nAdditionally, zend-mvc integrates with zend-view via a number of event listeners\nin the \nZend\\Mvc\\View\n namespace.\n\n\nThis section of the manual is designed to show you typical usage patterns of the\nview layer when using it with \nzend-mvc\n.\nThe assumption is that you are using the \nservice manager\n\nand the default MVC view strategies.\n\n\nConfiguration\n\n\nThe default configuration will typically work out-of-the-box. However, you will\nstill need to select Resolver Strategies and configure them, as well as\npotentially indicate alternate template names for things like the site layout,\n404 (not found) pages, and error pages. The code snippets below can be added to\nyour configuration to accomplish this. We recommend adding it to a\nsite-specific module, such as the \"Application\" module from the framework's\n\nZendSkeletonApplication\n,\nor to one of your autoloaded configurations within the \nconfig/autoload/\n\ndirectory.\n\n\nreturn [\n    'view_manager' => [\n        // The TemplateMapResolver allows you to directly map template names\n        // to specific templates. The following map would provide locations\n        // for a home page template (\"application/index/index\"), as well as for\n        // the layout (\"layout/layout\"), error pages (\"error/index\"), and\n        // 404 page (\"error/404\"), resolving them to view scripts.\n        'template_map' => [\n            'application/index/index' => __DIR__ .  '/../view/application/index/index.phtml',\n            'site/layout'             => __DIR__ . '/../view/layout/layout.phtml',\n            'error/index'             => __DIR__ . '/../view/error/index.phtml',\n            'error/404'               => __DIR__ . '/../view/error/404.phtml',\n        ],\n\n        // The TemplatePathStack takes an array of directories. Directories\n        // are then searched in LIFO order (it's a stack) for the requested\n        // view script. This is a nice solution for rapid application\n        // development, but potentially introduces performance expense in\n        // production due to the number of static calls necessary.\n        //\n        // The following adds an entry pointing to the view directory\n        // of the current module. Make sure your keys differ between modules\n        // to ensure that they are not overwritten -- or simply omit the key!\n        'template_path_stack' => [\n            'application' => __DIR__ . '/../view',\n        ],\n\n        // This will be used as the default suffix for template scripts\n        // resolving, it defaults to 'phtml'.\n        'default_template_suffix' => 'php',\n\n        // Set the template name for the site's layout.\n        //\n        // By default, the MVC's default Rendering Strategy uses the\n        // template name \"layout/layout\" for the site's layout.\n        // Here, we tell it to use the \"site/layout\" template,\n        // which we mapped via the TemplateMapResolver above.\n        'layout' => 'site/layout',\n\n        // By default, the MVC registers an \"exception strategy\", which is\n        // triggered when a requested action raises an exception; it creates\n        // a custom view model that wraps the exception, and selects a\n        // template. We'll set it to \"error/index\".\n        //\n        // Additionally, we'll tell it that we want to display an exception\n        // stack trace; you'll likely want to disable this by default.\n        'display_exceptions' => true,\n        'exception_template' => 'error/index',\n\n       // Another strategy the MVC registers by default is a \"route not\n       // found\" strategy. Basically, this gets triggered if (a) no route\n       // matches the current request, (b) the controller specified in the\n       // route match cannot be found in the service locator, (c) the controller\n       // specified in the route match does not implement the DispatchableInterface\n       // interface, or (d) if a response from a controller sets the\n       // response status to 404.\n       //\n       // The default template used in such situations is \"error\", just\n       // like the exception strategy. Here, we tell it to use the \"error/404\"\n       // template (which we mapped via the TemplateMapResolver, above).\n       //\n       // You can opt in to inject the reason for a 404 situation; see the\n       // various `Application\\:\\:ERROR_*`_ constants for a list of values.\n       // Additionally, a number of 404 situations derive from exceptions\n       // raised during routing or dispatching. You can opt-in to display\n       // these.\n       'display_not_found_reason' => true,\n       'not_found_template'       => 'error/404',\n    ],\n];\n\n\n\nControllers and View Models\n\n\nZend\\View\\View\n consumes \nViewModel\ns, passing them to the selected renderer.\nWhere do you create these, though?\n\n\nThe most explicit way is to create them in your controllers and return them.\n\n\nnamespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        $view = new ViewModel([\n            'message' => 'Hello world',\n        ]);\n        $view->setTemplate('foo/baz-bat/do-something-crazy');\n        return $view;\n    }\n}\n\n\n\nThis sets a \"message\" variable in the View Model, and sets the template name\n\"foo/baz-bat/do-something-crazy\". The View Model is then returned.\n\n\nIn most cases, you'll likely have a template name based on the module namespace,\ncontroller, and action. Considering that, and if you're simply passing some\nvariables, could this be made simpler?  Definitely.\n\n\nThe MVC registers a couple of listeners for controllers to automate this. The\nfirst will look to see if you returned an associative array from your\ncontroller; if so, it will create a View Model and make this associative array\nthe Variables Container; this View Model then replaces the\n\nMvcEvent\n's result. It will\nalso look to see if you returned nothing or \nnull\n; if so, it will create a View\nModel without any variables attached; this View Model also replaces the\n\nMvcEvent\n's result.\n\n\nThe second listener checks to see if the \nMvcEvent\n result is a View Model, and,\nif so, if it has a template associated with it. If not, it will inspect the\ncontroller matched during routing to determine the module namespace and the\ncontroller class name, and, if available, it's \"action\" parameter in order to\ncreate a template name. This will be \nmodule/controller/action\n, all normalized\nto lowercase, dash-separated words.\n\n\nAs an example, the controller \nFoo\\Controller\\BazBatController\n with action\n\"doSomethingCrazyAction\", would be mapped to the template\n\nfoo/baz-bat/do-something-crazy\n. As you can see, the words \"Controller\" and\n\"Action\" are omitted.\n\n\nIn practice, that means our previous example could be re-written as follows:\n\n\nnamespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        return [\n            'message' => 'Hello world',\n        ];\n    }\n}\n\n\n\nThe above method will likely work for the majority of use cases. When you need\nto specify a different template, explicitly create and return a View Model and\nspecify the template manually, as in the first example.\n\n\nNesting View Models\n\n\nThe other use case you may have for setting explicit View Models is if you wish\nto \nnest\n them. In other words, you might want to render templates to be\nincluded within the main View you return.\n\n\nAs an example, you may want the View from an action to be one primary section\nthat includes both an \"article\" and a couple of sidebars; one of the sidebars\nmay include content from multiple Views as well:\n\n\nnamespace Content\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass ArticleController extends AbstractActionController\n{\n    public function viewAction()\n    {\n        // get the article from the persistence layer, etc...\n\n        $view = new ViewModel();\n\n        // this is not needed since it matches \"module/controller/action\"\n        $view->setTemplate('content/article/view');\n\n        $articleView = new ViewModel(['article' => $article]);\n        $articleView->setTemplate('content/article');\n\n        $primarySidebarView = new ViewModel();\n        $primarySidebarView->setTemplate('content/main-sidebar');\n\n        $secondarySidebarView = new ViewModel();\n        $secondarySidebarView->setTemplate('content/secondary-sidebar');\n\n        $sidebarBlockView = new ViewModel();\n        $sidebarBlockView->setTemplate('content/block');\n\n        $secondarySidebarView->addChild($sidebarBlockView, 'block');\n\n        $view->addChild($articleView, 'article')\n             ->addChild($primarySidebarView, 'sidebar_primary')\n             ->addChild($secondarySidebarView, 'sidebar_secondary');\n\n        return $view;\n    }\n}\n\n\n\nThe above will create and return a View Model specifying the template\n\ncontent/article/view\n. When the View is rendered, it will render three child\nViews, the \n$articleView\n, \n$primarySidebarView\n, and \n$secondarySidebarView\n;\nthese will be captured to the \n$view\n's \narticle\n, \nsidebar_primary\n, and\n\nsidebar_secondary\n variables, respectively, so that when it renders, you may\ninclude that content. Additionally, the \n$secondarySidebarView\n will include an\nadditional View Model, \n$sidebarBlockView\n, which will be captured to its\n\nblock\n view variable.\n\n\nTo better visualize this, let's look at what the final content might look like,\nwith comments detailing where each nested view model is injected.\n\n\nHere are the templates, rendered based on a 12-column grid:\n\n\n<?php // \"content/article/view\" template ?>\n<!-- This is from the $view View Model, and the \"content/article/view\" template -->\n<div class=\"row content\">\n    <?= $this->article ?>\n\n    <?= $this->sidebar_primary ?>\n\n    <?= $this->sidebar_secondary ?>\n</div>\n\n\n\n<?php // \"content/article\" template ?>\n    <!-- This is from the $articleView View Model, and the \"content/article\"\n         template -->\n    <article class=\"span8\">\n        <?= $this->escapeHtml('article') ?>\n    </article>\n\n\n\n<?php // \"content/main-sidebar\" template ?>\n    <!-- This is from the $primarySidebarView View Model, and the\n         \"content/main-sidebar\" template -->\n    <div class=\"span2 sidebar\">\n        sidebar content...\n    </div>\n\n\n\n<?php // \"content/secondary-sidebar template ?>\n    <!-- This is from the $secondarySidebarView View Model, and the\n         \"content/secondary-sidebar\" template -->\n    <div class=\"span2 sidebar pull-right\">\n        <?= $this->block ?>\n    </div>\n\n\n\n<?php // \"content/block template ?>\n        <!-- This is from the $sidebarBlockView View Model, and the\n            \"content/block\" template -->\n        <div class=\"block\">\n            block content...\n        </div>\n\n\n\nAnd here is the aggregate, generated content:\n\n\n<!-- This is from the $view View Model, and the \"content/article/view\" template -->\n<div class=\"row content\">\n    <!-- This is from the $articleView View Model, and the \"content/article\"\n         template -->\n    <article class=\"span8\">\n        Lorem ipsum ....\n    </article>\n\n    <!-- This is from the $primarySidebarView View Model, and the\n         \"content/main-sidebar\" template -->\n    <div class=\"span2 sidebar\">\n        sidebar content...\n    </div>\n\n    <!-- This is from the $secondarySidebarView View Model, and the\n         \"content/secondary-sidebar\" template -->\n    <div class=\"span2 sidebar pull-right\">\n        <!-- This is from the $sidebarBlockView View Model, and the\n            \"content/block\" template -->\n        <div class=\"block\">\n            block content...\n        </div>\n    </div>\n</div>\n\n\n\nYou can achieve very complex markup using nested Views, while simultaneously\nkeeping the details of rendering isolated from the Request/Response lifecycle of\nthe controller.\n\n\nDealing with Layouts\n\n\nMost sites enforce a cohesive look-and-feel which we typically call the site's\n\"layout\". It includes the default stylesheets and JavaScript necessary, if any,\nas well as the basic markup structure into which all site content will be\ninjected.\n\n\nWithin zend-mvc, layouts are handled via nesting of View Models (\nsee the\nprevious example\n for examples of View Model nesting). The\n\nZend\\Mvc\\View\\Http\\ViewManager\n composes a View Model which acts as the \"root\"\nfor nested View Models. As such, it should contain the skeleton (or layout)\ntemplate for the site. All other content is then rendered and captured to view\nvariables of this root View Model.\n\n\nThe \nViewManager\n sets the layout template as \nlayout/layout\n by default. To\nchange this, you can add some configuration to the \nview_manager\n area of your\n\nconfiguration\n.\n\n\nA listener on the controllers, \nZend\\Mvc\\View\\Http\\InjectViewModelListener\n,\nwill take a View Model returned from a controller and inject it as a child of\nthe root (layout) View Model. By default, View Models will capture to the\n\"content\" variable of the root View Model. This means you can do the following\nin your layout view script:\n\n\n<html>\n    <head>\n        <title><?= $this->headTitle() ?></title>\n    </head>\n    <body>\n        <?= $this->content; ?>\n    </body>\n</html>\n\n\n\nIf you want to specify a different View variable for which to capture,\nexplicitly create a view model in your controller, and set its \"capture to\"\nvalue:\n\n\nnamespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        $view = new ViewModel([\n            'message' => 'Hello world',\n        ]);\n\n        // Capture to the layout view's \"article\" variable\n        $view->setCaptureTo('article');\n\n        return $view;\n    }\n}\n\n\n\nThere will be times you don't want to render a layout. For example, you might be\nanswering an API call which expects JSON or an XML payload, or you might be\nanswering an XHR request that expects a partial HTML payload. To do this,\nexplicitly create and return a view model from your controller, and mark it as\n\"terminal\", which will hint to the MVC listener that normally injects the\nreturned View Model into the layout View Model, to instead replace the layout\nview model.\n\n\nnamespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        $view = new ViewModel([\n            'message' => 'Hello world',\n        ]);\n\n        // Disable layouts; `MvcEvent` will use this View Model instead\n        $view->setTerminal(true);\n\n        return $view;\n    }\n}\n\n\n\nWhen discussing nesting View Models\n, we detailed a\nnested View Model which contained an article and sidebars. Sometimes, you may\nwant to provide additional View Models to the layout, instead of nesting in the\nreturned layout. This may be done by using the \nlayout()\n controller plugin,\nwhich returns the root View Model. You can then call the same \naddChild()\n\nmethod on it as we did in that previous example.\n\n\nnamespace Content\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass ArticleController extends AbstractActionController\n{\n    public function viewAction()\n    {\n        // get the article from the persistence layer, etc...\n\n        // Get the \"layout\" view model and inject a sidebar\n        $layout = $this->layout();\n        $sidebarView = new ViewModel();\n        $sidebarView->setTemplate('content/sidebar');\n        $layout->addChild($sidebarView, 'sidebar');\n\n        // Create and return a view model for the retrieved article\n        $view = new ViewModel(['article' => $article]);\n        $view->setTemplate('content/article');\n        return $view;\n    }\n}\n\n\n\nYou could also use this technique to select a different layout, by calling the\n\nsetTemplate()\n method of the layout View Model:\n\n\n//In a controller\nnamespace Content\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass ArticleController extends AbstractActionController\n{\n    public function viewAction()\n    {\n        // get the article from the persistence layer, etc...\n\n        // Get the \"layout\" view model and set an alternate template\n        $layout = $this->layout();\n        $layout->setTemplate('article/layout');\n\n        // Create and return a view model for the retrieved article\n        $view = new ViewModel(['article' => $article]);\n        $view->setTemplate('content/article');\n        return $view;\n    }\n}\n\n\n\nSometimes, you may want to access the layout from within your actual view\nscripts when using the \nPhpRenderer\n. Reasons might include wanting to change\nthe layout template, or wanting to either access or inject layout view variables.\nSimilar to the \nlayout()\n controller plugin, you can use the \nlayout()\n View Helper.\nIf you provide a string argument to it, you will change the template; if you\nprovide no arguments, the root layout View Model is returned.\n\n\n//In a view script\n\n// Change the layout:\n$this->layout('alternate/layout'); // OR\n$this->layout()->setTemplate('alternate/layout');\n\n// Access a layout variable.\n// Since access to the base view model is relatively easy, it becomes a\n// reasonable place to store things such as API keys, which other view scripts\n// may need.\n$layout       = $this->layout();\n$disqusApiKey = false;\nif (isset($layout->disqusApiKey)) {\n    $disqusApiKey = $layout->disqusApiKey;\n}\n\n// Set a layout variable\n$this->layout()->footer = $this->render('article/footer');\n\n\n\nCommonly, you may want to alter the layout based on the current \nmodule\n. This\nrequires (a) detecting if the controller matched in routing belongs to this\nmodule, and then (b) changing the template of the View Model.\n\n\nThe place to do these actions is in a listener. It should listen either to the\n\nroute\n event at low (negative) priority, or on the \ndispatch\n event, at any\npriority. Typically, you will register this during the bootstrap event.\n\n\nnamespace Content;\n\nuse Zend\\Mvc\\MvcEvent;\n\nclass Module\n{\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap(MvcEvent $e)\n    {\n        // Register a dispatch event\n        $app = $e->getParam('application');\n        $app->getEventManager()->attach('dispatch', [$this, 'setLayout']);\n    }\n\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function setLayout(MvcEvent $e)\n    {\n        $matches    = $e->getRouteMatch();\n        $controller = $matches->getParam('controller');\n        if (false === strpos($controller, __NAMESPACE__)) {\n            // not a controller from this module\n            return;\n        }\n\n        // Set the layout template\n        $viewModel = $e->getViewModel();\n        $viewModel->setTemplate('content/layout');\n    }\n}\n\n\n\nCreating and Registering Alternate Rendering and Response Strategies\n\n\nZend\\View\\View\n does very little. Its workflow is essentially to martial a\n\nViewEvent\n, and then trigger two events, \nrenderer\n and \nresponse\n. You can\nattach \"strategies\" to these events, using the methods \naddRenderingStrategy()\n\nand \naddResponseStrategy()\n, respectively. A Rendering Strategy introspects the\nRequest object (or any other criteria) in order to select a Renderer (or fail to\nselect one). A Response Strategy determines how to populate the Response based\non the result of rendering.\n\n\nzend-view ships with three Rendering and Response Strategies that you can use\nwithin your application.\n\n\n\n\nZend\\View\\Strategy\\PhpRendererStrategy\n. This strategy is a \"catch-all\" in\n  that it will always return the \nZend\\View\\Renderer\\PhpRenderer\n and populate\n  the Response body with the results of rendering.\n\n\nZend\\View\\Strategy\\JsonStrategy\n. This strategy will return the\n  \nZend\\View\\Renderer\\JsonRenderer\n, and populate the Response body with the\n  JSON value returned, as well as set a \nContent-Type\n header with a value of\n  \napplication/json\n.\n\n\nZend\\View\\Strategy\\FeedStrategy\n. This strategy will return the \n  \nZend\\View\\Renderer\\FeedRenderer\n, setting the feed type to\n  either \"rss\" or \"atom\", based on what was matched. Its Response strategy will\n  populate the Response body with the generated feed, as well as set a\n  \nContent-Type\n header with the appropriate value based on feed type.\n\n\n\n\nBy default, only the \nPhpRendererStrategy\n is registered, meaning you will need\nto register the other Strategies yourself if you want to use them. Additionally,\nit means that you will likely want to register these at higher priority to\nensure they match before the \nPhpRendererStrategy\n. As an example, let's\nregister the \nJsonStrategy\n:\n\n\nnamespace Application;\n\nuse Zend\\Mvc\\MvcEvent;\n\nclass Module\n{\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap(MvcEvent $e)\n    {\n        // Register a \"render\" event, at high priority (so it executes prior\n        // to the view attempting to render)\n        $app = $e->getApplication();\n        $app->getEventManager()->attach('render', [$this, 'registerJsonStrategy'], 100);\n    }\n\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function registerJsonStrategy(MvcEvent $e)\n    {\n        $app          = $e->getTarget();\n        $locator      = $app->getServiceManager();\n        $view         = $locator->get('Zend\\View\\View');\n        $jsonStrategy = $locator->get('ViewJsonStrategy');\n\n        // Attach strategy, which is a listener aggregate, at high priority\n        $jsonStrategy->attach($view->getEventManager(), 100);\n    }\n}\n\n\n\nThe above will register the \nJsonStrategy\n with the \"render\" event, such that it\nexecutes prior to the \nPhpRendererStrategy\n, and thus ensure that a JSON payload\nis created when the controller returns a \nJsonModel\n.\n\n\nYou could also use the module configuration to add the strategies:\n\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    /**\n     * Returns configuration to merge with application configuration\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        return [\n            /* ... */\n            'view_manager' => [\n                /* ... */\n                'strategies' => [\n                    'ViewJsonStrategy',\n                ],\n            ],\n        ];\n    }\n}\n\n\nWhat if you want this to happen only in specific modules, or specific\ncontrollers? One way is similar to the last example in the\n\nprevious section on layouts\n, where we detailed changing\nthe layout for a specific module:\n\n\nnamespace Application;\n\nuse Zend\\Mvc\\MvcEvent;\n\nclass Module\n{\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap(MvcEvent $e)\n    {\n        // Register a render event\n        $app = $e->getParam('application');\n        $app->getEventManager()->attach('render', [$this, 'registerJsonStrategy'], 100);\n    }\n\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function registerJsonStrategy(MvcEvent $e)\n    {\n        $matches    = $e->getRouteMatch();\n        $controller = $matches->getParam('controller');\n        if (false === strpos($controller, __NAMESPACE__)) {\n            // not a controller from this module\n            return;\n        }\n\n        // Potentially, you could be even more selective at this point, and test\n        // for specific controller classes, and even specific actions or request\n        // methods.\n\n        // Set the JSON strategy when controllers from this module are selected\n        $app          = $e->getTarget();\n        $locator      = $app->getServiceManager();\n        $view         = $locator->get('Zend\\View\\View');\n        $jsonStrategy = $locator->get('ViewJsonStrategy');\n\n        // Attach strategy, which is a listener aggregate, at high priority\n        $view->getEventManager()->attach($jsonStrategy, 100);\n    }\n}\n\n\n\nWhile the above examples detail using the \nJsonStrategy\n, the same could be done\nfor the \nFeedStrategy\n.\n\n\nIf you successfully registered the Strategy you need to use the appropriate \nViewModel\n:\n\nnamespace Application;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\View\\Model\\JsonModel;\nuse Zend\\View\\Model\\FeedModel;\n\nclass MyController extends AbstractActionController\n{\n    /**\n     * Lists the items as HTML\n     */\n    public function listAction()\n    {\n        $items = /* ... get items ... */;\n        $viewModel = new ViewModel();\n        $viewModel->setVariable('items', $items);\n        return $viewModel;\n    }\n\n    /**\n     * Lists the items as JSON\n     */\n    public function listJsonAction()\n    {\n        $items = /* ... get items ... */;\n        $viewModel = new JsonModel();\n        $viewModel->setVariable('items', $items);\n        return $viewModel;\n    }\n\n    /**\n     * Lists the items as a Feed\n     */\n    public function listFeedAction()\n    {\n        $items = /* ... get items ... */;\n        $viewModel = new FeedModel();\n        $viewModel->setVariable('items', $items);\n        return $viewModel;\n    }\n}\n\n\nOr you could switch the \nViewModel\n dynamically based on the \"Accept\" HTTP Header with the \n\nZend-Mvc-Plugin AcceptableViewModelSelector\n.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "zend-view provides the \"View\" layer of Zend Framework 2's MVC system. It is a\nmulti-tiered system allowing a variety of mechanisms for extension,\nsubstitution, and more.  The components of the view layer are as follows:   Variables Containers  hold variables and callbacks that you wish to\n  represent in the view.  Often-times, a Variables Container will also provide\n  mechanisms for context-specific escaping of variables and more.  View Models  hold Variables Containers, specify the template to use (if\n  any), and optionally provide rendering options (more on that below). View\n  Models may be nested in order to represent complex structures.  Renderers  take View Models and provide a representation of them to return.\n  zend-view ships with three renderers by default: a  PhpRenderer  which\n  utilizes PHP templates in order to generate markup, a  JsonRenderer , and a\n   FeedRenderer  for generating RSS and Atom feeds.  Resolvers  utilize Resolver Strategies to resolve a template name to a\n  resource a Renderer may consume. As an example, a Resolver may take the name\n  \"blog/entry\" and resolve it to a PHP view script.  The  View  consists of strategies that map the current Request to a\n  Renderer, and strategies for injecting the result of rendering to the\n  Response.  Rendering Strategies  listen to the  Zend\\View\\ViewEvent::EVENT_RENDERER \n  event of the View and decide which Renderer should be selected based on the\n  Request or other criteria.  Response Strategies  are used to inject the Response object with the\n  results of rendering. That may also include taking actions such as setting\n  Content-Type headers.   Additionally, zend-mvc integrates with zend-view via a number of event listeners\nin the  Zend\\Mvc\\View  namespace.  This section of the manual is designed to show you typical usage patterns of the\nview layer when using it with  zend-mvc .\nThe assumption is that you are using the  service manager \nand the default MVC view strategies.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#configuration",
            "text": "The default configuration will typically work out-of-the-box. However, you will\nstill need to select Resolver Strategies and configure them, as well as\npotentially indicate alternate template names for things like the site layout,\n404 (not found) pages, and error pages. The code snippets below can be added to\nyour configuration to accomplish this. We recommend adding it to a\nsite-specific module, such as the \"Application\" module from the framework's ZendSkeletonApplication ,\nor to one of your autoloaded configurations within the  config/autoload/ \ndirectory.  return [\n    'view_manager' => [\n        // The TemplateMapResolver allows you to directly map template names\n        // to specific templates. The following map would provide locations\n        // for a home page template (\"application/index/index\"), as well as for\n        // the layout (\"layout/layout\"), error pages (\"error/index\"), and\n        // 404 page (\"error/404\"), resolving them to view scripts.\n        'template_map' => [\n            'application/index/index' => __DIR__ .  '/../view/application/index/index.phtml',\n            'site/layout'             => __DIR__ . '/../view/layout/layout.phtml',\n            'error/index'             => __DIR__ . '/../view/error/index.phtml',\n            'error/404'               => __DIR__ . '/../view/error/404.phtml',\n        ],\n\n        // The TemplatePathStack takes an array of directories. Directories\n        // are then searched in LIFO order (it's a stack) for the requested\n        // view script. This is a nice solution for rapid application\n        // development, but potentially introduces performance expense in\n        // production due to the number of static calls necessary.\n        //\n        // The following adds an entry pointing to the view directory\n        // of the current module. Make sure your keys differ between modules\n        // to ensure that they are not overwritten -- or simply omit the key!\n        'template_path_stack' => [\n            'application' => __DIR__ . '/../view',\n        ],\n\n        // This will be used as the default suffix for template scripts\n        // resolving, it defaults to 'phtml'.\n        'default_template_suffix' => 'php',\n\n        // Set the template name for the site's layout.\n        //\n        // By default, the MVC's default Rendering Strategy uses the\n        // template name \"layout/layout\" for the site's layout.\n        // Here, we tell it to use the \"site/layout\" template,\n        // which we mapped via the TemplateMapResolver above.\n        'layout' => 'site/layout',\n\n        // By default, the MVC registers an \"exception strategy\", which is\n        // triggered when a requested action raises an exception; it creates\n        // a custom view model that wraps the exception, and selects a\n        // template. We'll set it to \"error/index\".\n        //\n        // Additionally, we'll tell it that we want to display an exception\n        // stack trace; you'll likely want to disable this by default.\n        'display_exceptions' => true,\n        'exception_template' => 'error/index',\n\n       // Another strategy the MVC registers by default is a \"route not\n       // found\" strategy. Basically, this gets triggered if (a) no route\n       // matches the current request, (b) the controller specified in the\n       // route match cannot be found in the service locator, (c) the controller\n       // specified in the route match does not implement the DispatchableInterface\n       // interface, or (d) if a response from a controller sets the\n       // response status to 404.\n       //\n       // The default template used in such situations is \"error\", just\n       // like the exception strategy. Here, we tell it to use the \"error/404\"\n       // template (which we mapped via the TemplateMapResolver, above).\n       //\n       // You can opt in to inject the reason for a 404 situation; see the\n       // various `Application\\:\\:ERROR_*`_ constants for a list of values.\n       // Additionally, a number of 404 situations derive from exceptions\n       // raised during routing or dispatching. You can opt-in to display\n       // these.\n       'display_not_found_reason' => true,\n       'not_found_template'       => 'error/404',\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/quick-start/#controllers-and-view-models",
            "text": "Zend\\View\\View  consumes  ViewModel s, passing them to the selected renderer.\nWhere do you create these, though?  The most explicit way is to create them in your controllers and return them.  namespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        $view = new ViewModel([\n            'message' => 'Hello world',\n        ]);\n        $view->setTemplate('foo/baz-bat/do-something-crazy');\n        return $view;\n    }\n}  This sets a \"message\" variable in the View Model, and sets the template name\n\"foo/baz-bat/do-something-crazy\". The View Model is then returned.  In most cases, you'll likely have a template name based on the module namespace,\ncontroller, and action. Considering that, and if you're simply passing some\nvariables, could this be made simpler?  Definitely.  The MVC registers a couple of listeners for controllers to automate this. The\nfirst will look to see if you returned an associative array from your\ncontroller; if so, it will create a View Model and make this associative array\nthe Variables Container; this View Model then replaces the MvcEvent 's result. It will\nalso look to see if you returned nothing or  null ; if so, it will create a View\nModel without any variables attached; this View Model also replaces the MvcEvent 's result.  The second listener checks to see if the  MvcEvent  result is a View Model, and,\nif so, if it has a template associated with it. If not, it will inspect the\ncontroller matched during routing to determine the module namespace and the\ncontroller class name, and, if available, it's \"action\" parameter in order to\ncreate a template name. This will be  module/controller/action , all normalized\nto lowercase, dash-separated words.  As an example, the controller  Foo\\Controller\\BazBatController  with action\n\"doSomethingCrazyAction\", would be mapped to the template foo/baz-bat/do-something-crazy . As you can see, the words \"Controller\" and\n\"Action\" are omitted.  In practice, that means our previous example could be re-written as follows:  namespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        return [\n            'message' => 'Hello world',\n        ];\n    }\n}  The above method will likely work for the majority of use cases. When you need\nto specify a different template, explicitly create and return a View Model and\nspecify the template manually, as in the first example.",
            "title": "Controllers and View Models"
        },
        {
            "location": "/quick-start/#nesting-view-models",
            "text": "The other use case you may have for setting explicit View Models is if you wish\nto  nest  them. In other words, you might want to render templates to be\nincluded within the main View you return.  As an example, you may want the View from an action to be one primary section\nthat includes both an \"article\" and a couple of sidebars; one of the sidebars\nmay include content from multiple Views as well:  namespace Content\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass ArticleController extends AbstractActionController\n{\n    public function viewAction()\n    {\n        // get the article from the persistence layer, etc...\n\n        $view = new ViewModel();\n\n        // this is not needed since it matches \"module/controller/action\"\n        $view->setTemplate('content/article/view');\n\n        $articleView = new ViewModel(['article' => $article]);\n        $articleView->setTemplate('content/article');\n\n        $primarySidebarView = new ViewModel();\n        $primarySidebarView->setTemplate('content/main-sidebar');\n\n        $secondarySidebarView = new ViewModel();\n        $secondarySidebarView->setTemplate('content/secondary-sidebar');\n\n        $sidebarBlockView = new ViewModel();\n        $sidebarBlockView->setTemplate('content/block');\n\n        $secondarySidebarView->addChild($sidebarBlockView, 'block');\n\n        $view->addChild($articleView, 'article')\n             ->addChild($primarySidebarView, 'sidebar_primary')\n             ->addChild($secondarySidebarView, 'sidebar_secondary');\n\n        return $view;\n    }\n}  The above will create and return a View Model specifying the template content/article/view . When the View is rendered, it will render three child\nViews, the  $articleView ,  $primarySidebarView , and  $secondarySidebarView ;\nthese will be captured to the  $view 's  article ,  sidebar_primary , and sidebar_secondary  variables, respectively, so that when it renders, you may\ninclude that content. Additionally, the  $secondarySidebarView  will include an\nadditional View Model,  $sidebarBlockView , which will be captured to its block  view variable.  To better visualize this, let's look at what the final content might look like,\nwith comments detailing where each nested view model is injected.  Here are the templates, rendered based on a 12-column grid:  <?php // \"content/article/view\" template ?>\n<!-- This is from the $view View Model, and the \"content/article/view\" template -->\n<div class=\"row content\">\n    <?= $this->article ?>\n\n    <?= $this->sidebar_primary ?>\n\n    <?= $this->sidebar_secondary ?>\n</div>  <?php // \"content/article\" template ?>\n    <!-- This is from the $articleView View Model, and the \"content/article\"\n         template -->\n    <article class=\"span8\">\n        <?= $this->escapeHtml('article') ?>\n    </article>  <?php // \"content/main-sidebar\" template ?>\n    <!-- This is from the $primarySidebarView View Model, and the\n         \"content/main-sidebar\" template -->\n    <div class=\"span2 sidebar\">\n        sidebar content...\n    </div>  <?php // \"content/secondary-sidebar template ?>\n    <!-- This is from the $secondarySidebarView View Model, and the\n         \"content/secondary-sidebar\" template -->\n    <div class=\"span2 sidebar pull-right\">\n        <?= $this->block ?>\n    </div>  <?php // \"content/block template ?>\n        <!-- This is from the $sidebarBlockView View Model, and the\n            \"content/block\" template -->\n        <div class=\"block\">\n            block content...\n        </div>  And here is the aggregate, generated content:  <!-- This is from the $view View Model, and the \"content/article/view\" template -->\n<div class=\"row content\">\n    <!-- This is from the $articleView View Model, and the \"content/article\"\n         template -->\n    <article class=\"span8\">\n        Lorem ipsum ....\n    </article>\n\n    <!-- This is from the $primarySidebarView View Model, and the\n         \"content/main-sidebar\" template -->\n    <div class=\"span2 sidebar\">\n        sidebar content...\n    </div>\n\n    <!-- This is from the $secondarySidebarView View Model, and the\n         \"content/secondary-sidebar\" template -->\n    <div class=\"span2 sidebar pull-right\">\n        <!-- This is from the $sidebarBlockView View Model, and the\n            \"content/block\" template -->\n        <div class=\"block\">\n            block content...\n        </div>\n    </div>\n</div>  You can achieve very complex markup using nested Views, while simultaneously\nkeeping the details of rendering isolated from the Request/Response lifecycle of\nthe controller.",
            "title": "Nesting View Models"
        },
        {
            "location": "/quick-start/#dealing-with-layouts",
            "text": "Most sites enforce a cohesive look-and-feel which we typically call the site's\n\"layout\". It includes the default stylesheets and JavaScript necessary, if any,\nas well as the basic markup structure into which all site content will be\ninjected.  Within zend-mvc, layouts are handled via nesting of View Models ( see the\nprevious example  for examples of View Model nesting). The Zend\\Mvc\\View\\Http\\ViewManager  composes a View Model which acts as the \"root\"\nfor nested View Models. As such, it should contain the skeleton (or layout)\ntemplate for the site. All other content is then rendered and captured to view\nvariables of this root View Model.  The  ViewManager  sets the layout template as  layout/layout  by default. To\nchange this, you can add some configuration to the  view_manager  area of your configuration .  A listener on the controllers,  Zend\\Mvc\\View\\Http\\InjectViewModelListener ,\nwill take a View Model returned from a controller and inject it as a child of\nthe root (layout) View Model. By default, View Models will capture to the\n\"content\" variable of the root View Model. This means you can do the following\nin your layout view script:  <html>\n    <head>\n        <title><?= $this->headTitle() ?></title>\n    </head>\n    <body>\n        <?= $this->content; ?>\n    </body>\n</html>  If you want to specify a different View variable for which to capture,\nexplicitly create a view model in your controller, and set its \"capture to\"\nvalue:  namespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        $view = new ViewModel([\n            'message' => 'Hello world',\n        ]);\n\n        // Capture to the layout view's \"article\" variable\n        $view->setCaptureTo('article');\n\n        return $view;\n    }\n}  There will be times you don't want to render a layout. For example, you might be\nanswering an API call which expects JSON or an XML payload, or you might be\nanswering an XHR request that expects a partial HTML payload. To do this,\nexplicitly create and return a view model from your controller, and mark it as\n\"terminal\", which will hint to the MVC listener that normally injects the\nreturned View Model into the layout View Model, to instead replace the layout\nview model.  namespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass BazBatController extends AbstractActionController\n{\n    public function doSomethingCrazyAction()\n    {\n        $view = new ViewModel([\n            'message' => 'Hello world',\n        ]);\n\n        // Disable layouts; `MvcEvent` will use this View Model instead\n        $view->setTerminal(true);\n\n        return $view;\n    }\n}  When discussing nesting View Models , we detailed a\nnested View Model which contained an article and sidebars. Sometimes, you may\nwant to provide additional View Models to the layout, instead of nesting in the\nreturned layout. This may be done by using the  layout()  controller plugin,\nwhich returns the root View Model. You can then call the same  addChild() \nmethod on it as we did in that previous example.  namespace Content\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass ArticleController extends AbstractActionController\n{\n    public function viewAction()\n    {\n        // get the article from the persistence layer, etc...\n\n        // Get the \"layout\" view model and inject a sidebar\n        $layout = $this->layout();\n        $sidebarView = new ViewModel();\n        $sidebarView->setTemplate('content/sidebar');\n        $layout->addChild($sidebarView, 'sidebar');\n\n        // Create and return a view model for the retrieved article\n        $view = new ViewModel(['article' => $article]);\n        $view->setTemplate('content/article');\n        return $view;\n    }\n}  You could also use this technique to select a different layout, by calling the setTemplate()  method of the layout View Model:  //In a controller\nnamespace Content\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass ArticleController extends AbstractActionController\n{\n    public function viewAction()\n    {\n        // get the article from the persistence layer, etc...\n\n        // Get the \"layout\" view model and set an alternate template\n        $layout = $this->layout();\n        $layout->setTemplate('article/layout');\n\n        // Create and return a view model for the retrieved article\n        $view = new ViewModel(['article' => $article]);\n        $view->setTemplate('content/article');\n        return $view;\n    }\n}  Sometimes, you may want to access the layout from within your actual view\nscripts when using the  PhpRenderer . Reasons might include wanting to change\nthe layout template, or wanting to either access or inject layout view variables.\nSimilar to the  layout()  controller plugin, you can use the  layout()  View Helper.\nIf you provide a string argument to it, you will change the template; if you\nprovide no arguments, the root layout View Model is returned.  //In a view script\n\n// Change the layout:\n$this->layout('alternate/layout'); // OR\n$this->layout()->setTemplate('alternate/layout');\n\n// Access a layout variable.\n// Since access to the base view model is relatively easy, it becomes a\n// reasonable place to store things such as API keys, which other view scripts\n// may need.\n$layout       = $this->layout();\n$disqusApiKey = false;\nif (isset($layout->disqusApiKey)) {\n    $disqusApiKey = $layout->disqusApiKey;\n}\n\n// Set a layout variable\n$this->layout()->footer = $this->render('article/footer');  Commonly, you may want to alter the layout based on the current  module . This\nrequires (a) detecting if the controller matched in routing belongs to this\nmodule, and then (b) changing the template of the View Model.  The place to do these actions is in a listener. It should listen either to the route  event at low (negative) priority, or on the  dispatch  event, at any\npriority. Typically, you will register this during the bootstrap event.  namespace Content;\n\nuse Zend\\Mvc\\MvcEvent;\n\nclass Module\n{\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap(MvcEvent $e)\n    {\n        // Register a dispatch event\n        $app = $e->getParam('application');\n        $app->getEventManager()->attach('dispatch', [$this, 'setLayout']);\n    }\n\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function setLayout(MvcEvent $e)\n    {\n        $matches    = $e->getRouteMatch();\n        $controller = $matches->getParam('controller');\n        if (false === strpos($controller, __NAMESPACE__)) {\n            // not a controller from this module\n            return;\n        }\n\n        // Set the layout template\n        $viewModel = $e->getViewModel();\n        $viewModel->setTemplate('content/layout');\n    }\n}",
            "title": "Dealing with Layouts"
        },
        {
            "location": "/quick-start/#creating-and-registering-alternate-rendering-and-response-strategies",
            "text": "Zend\\View\\View  does very little. Its workflow is essentially to martial a ViewEvent , and then trigger two events,  renderer  and  response . You can\nattach \"strategies\" to these events, using the methods  addRenderingStrategy() \nand  addResponseStrategy() , respectively. A Rendering Strategy introspects the\nRequest object (or any other criteria) in order to select a Renderer (or fail to\nselect one). A Response Strategy determines how to populate the Response based\non the result of rendering.  zend-view ships with three Rendering and Response Strategies that you can use\nwithin your application.   Zend\\View\\Strategy\\PhpRendererStrategy . This strategy is a \"catch-all\" in\n  that it will always return the  Zend\\View\\Renderer\\PhpRenderer  and populate\n  the Response body with the results of rendering.  Zend\\View\\Strategy\\JsonStrategy . This strategy will return the\n   Zend\\View\\Renderer\\JsonRenderer , and populate the Response body with the\n  JSON value returned, as well as set a  Content-Type  header with a value of\n   application/json .  Zend\\View\\Strategy\\FeedStrategy . This strategy will return the \n   Zend\\View\\Renderer\\FeedRenderer , setting the feed type to\n  either \"rss\" or \"atom\", based on what was matched. Its Response strategy will\n  populate the Response body with the generated feed, as well as set a\n   Content-Type  header with the appropriate value based on feed type.   By default, only the  PhpRendererStrategy  is registered, meaning you will need\nto register the other Strategies yourself if you want to use them. Additionally,\nit means that you will likely want to register these at higher priority to\nensure they match before the  PhpRendererStrategy . As an example, let's\nregister the  JsonStrategy :  namespace Application;\n\nuse Zend\\Mvc\\MvcEvent;\n\nclass Module\n{\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap(MvcEvent $e)\n    {\n        // Register a \"render\" event, at high priority (so it executes prior\n        // to the view attempting to render)\n        $app = $e->getApplication();\n        $app->getEventManager()->attach('render', [$this, 'registerJsonStrategy'], 100);\n    }\n\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function registerJsonStrategy(MvcEvent $e)\n    {\n        $app          = $e->getTarget();\n        $locator      = $app->getServiceManager();\n        $view         = $locator->get('Zend\\View\\View');\n        $jsonStrategy = $locator->get('ViewJsonStrategy');\n\n        // Attach strategy, which is a listener aggregate, at high priority\n        $jsonStrategy->attach($view->getEventManager(), 100);\n    }\n}  The above will register the  JsonStrategy  with the \"render\" event, such that it\nexecutes prior to the  PhpRendererStrategy , and thus ensure that a JSON payload\nis created when the controller returns a  JsonModel .  You could also use the module configuration to add the strategies: namespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    /**\n     * Returns configuration to merge with application configuration\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        return [\n            /* ... */\n            'view_manager' => [\n                /* ... */\n                'strategies' => [\n                    'ViewJsonStrategy',\n                ],\n            ],\n        ];\n    }\n}  What if you want this to happen only in specific modules, or specific\ncontrollers? One way is similar to the last example in the previous section on layouts , where we detailed changing\nthe layout for a specific module:  namespace Application;\n\nuse Zend\\Mvc\\MvcEvent;\n\nclass Module\n{\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap(MvcEvent $e)\n    {\n        // Register a render event\n        $app = $e->getParam('application');\n        $app->getEventManager()->attach('render', [$this, 'registerJsonStrategy'], 100);\n    }\n\n    /**\n     * @param  MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function registerJsonStrategy(MvcEvent $e)\n    {\n        $matches    = $e->getRouteMatch();\n        $controller = $matches->getParam('controller');\n        if (false === strpos($controller, __NAMESPACE__)) {\n            // not a controller from this module\n            return;\n        }\n\n        // Potentially, you could be even more selective at this point, and test\n        // for specific controller classes, and even specific actions or request\n        // methods.\n\n        // Set the JSON strategy when controllers from this module are selected\n        $app          = $e->getTarget();\n        $locator      = $app->getServiceManager();\n        $view         = $locator->get('Zend\\View\\View');\n        $jsonStrategy = $locator->get('ViewJsonStrategy');\n\n        // Attach strategy, which is a listener aggregate, at high priority\n        $view->getEventManager()->attach($jsonStrategy, 100);\n    }\n}  While the above examples detail using the  JsonStrategy , the same could be done\nfor the  FeedStrategy .  If you successfully registered the Strategy you need to use the appropriate  ViewModel : namespace Application;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\View\\Model\\JsonModel;\nuse Zend\\View\\Model\\FeedModel;\n\nclass MyController extends AbstractActionController\n{\n    /**\n     * Lists the items as HTML\n     */\n    public function listAction()\n    {\n        $items = /* ... get items ... */;\n        $viewModel = new ViewModel();\n        $viewModel->setVariable('items', $items);\n        return $viewModel;\n    }\n\n    /**\n     * Lists the items as JSON\n     */\n    public function listJsonAction()\n    {\n        $items = /* ... get items ... */;\n        $viewModel = new JsonModel();\n        $viewModel->setVariable('items', $items);\n        return $viewModel;\n    }\n\n    /**\n     * Lists the items as a Feed\n     */\n    public function listFeedAction()\n    {\n        $items = /* ... get items ... */;\n        $viewModel = new FeedModel();\n        $viewModel->setVariable('items', $items);\n        return $viewModel;\n    }\n}  Or you could switch the  ViewModel  dynamically based on the \"Accept\" HTTP Header with the  Zend-Mvc-Plugin AcceptableViewModelSelector .",
            "title": "Creating and Registering Alternate Rendering and Response Strategies"
        },
        {
            "location": "/php-renderer/",
            "text": "The PhpRenderer\n\n\nZend\\View\\Renderer\\PhpRenderer\n \"renders\" view scripts written in PHP,\ncapturing and returning the output. It composes Variable containers and/or View\nModels, a helper plugin manager for \nhelpers\n, and optional\nfiltering of the captured output.\n\n\nThe \nPhpRenderer\n is template-system agnostic; you may use PHP as your template\nlanguage, or create instances of other template systems and manipulate them\nwithin your view script. Anything you can do with PHP is available to you.\n\n\nUsage\n\n\nBasic usage consists of instantiating or otherwise obtaining an instance of the\n\nPhpRenderer\n, providing it with a resolver which will resolve templates to PHP\nview scripts, and then calling its \nrender()\n method.\n\n\nInstantiating a renderer:\n\n\nuse Zend\\View\\Renderer\\PhpRenderer;\n\n$renderer = new PhpRenderer();\n\n\n\nzend-view ships with several types of \"resolvers\", which are used to resolve a\ntemplate name to a resource a renderer can consume. The ones we will usually use\nwith the \nPhpRenderer\n are:\n\n\n\n\nZend\\View\\Resolver\\TemplateMapResolver\n, which simply maps template names\n  directly to view scripts.\n\n\nZend\\View\\Resolver\\TemplatePathStack\n, which creates a LIFO stack of script\n  directories in which to search for a view script. By default, it appends the\n  suffix \n.phtml\n to the requested template name, and then loops through the\n  script directories; if it finds a file matching the requested template, it\n  returns the full file path.\n\n\nZend\\View\\Resolver\\RelativeFallbackResolver\n, which allows using short\n  template name into partial rendering. It is used as wrapper for each of two\n  aforesaid resolvers. For example, this allows usage of partial template paths\n  such as \nmy/module/script/path/my-view/some/partial.phtml\n, while rendering\n  template \nmy/module/script/path/my-view\n by short name \nsome/partial\n.\n\n\nZend\\View\\Resolver\\AggregateResolver\n, which allows attaching a FIFO queue of\n  resolvers to consult.\n\n\n\n\nWe suggest using the \nAggregateResolver\n, as it allows you to create a\nmulti-tiered strategy for resolving template names.\n\n\nProgrammatically, you would then do something like this:\n\n\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n$renderer = new PhpRenderer();\n\n$resolver = new Resolver\\AggregateResolver();\n\n$renderer->setResolver($resolver);\n\n$map = new Resolver\\TemplateMapResolver([\n    'layout'      => __DIR__ . '/view/layout.phtml',\n    'index/index' => __DIR__ . '/view/index/index.phtml',\n]);\n$stack = new Resolver\\TemplatePathStack([\n    'script_paths' => [\n        __DIR__ . '/view',\n        $someOtherPath\n    ],\n]);\n\n// Attach resolvers to the aggregate:\n$resolver\n    ->attach($map)    // this will be consulted first, and is the fastest lookup\n    ->attach($stack)  // filesystem-based lookup\n    ->attach(new Resolver\\RelativeFallbackResolver($map)) // allow short template names\n    ->attach(new Resolver\\RelativeFallbackResolver($stack));\n\n\n\nYou can also specify a specific priority value when registering resolvers, with\nhigh, positive integers getting higher priority, and low, negative integers\ngetting low priority, when resolving.\n\n\nIf you are started your application via the \nskeleton\napplication\n, you can\nprovide the above via configuration:\n\n\n// In the Application module configuration\n// (module/Application/config/module.config.php):\nreturn [\n    'view_manager' => [\n        'template_map' => [\n            'layout'      => __DIR__ . '/../view/layout.phtml',\n            'index/index' => __DIR__ . '/../view/index/index.phtml',\n        ],\n        'template_path_stack' => [\n            'application' => __DIR__ . '/../view',\n        ],\n    ],\n];\n\n\n\nIf you did not begin with the skeleton application, you will need to write your\nown factories for creating each resolver and wiring them to the\n\nAggregateResolver\n and injecting into the \nPhpRenderer\n.\n\n\nNow that we have our \nPhpRenderer\n instance, and it can find templates, let's\ninject some variables. This can be done in 4 different ways.\n\n\n\n\nPass an associative array (or \nArrayAccess\n instance, or \nZend\\View\\Variables\n\n  instance) of items as the second argument to \nrender()\n:\n  \n$renderer->render($templateName, array('foo' =&gt; 'bar))\n\n\nAssign a \nZend\\View\\Variables\n instance, associative array, or \nArrayAccess\n\n  instance to the \nsetVars()\n method.\n\n\nAssign variables as instance properties of the renderer: \n$renderer->foo =\n  'bar'\n. This essentially proxies to an instance of \nVariables\n composed\n  internally in the renderer by default.\n\n\nCreate a \nViewModel\n instance, assign variables to that, and pass the\n  \nViewModel\n to the \nrender()\n method:\n\n\n\n\nAs an example of the latter:\n\n\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\View\\Renderer\\PhpRenderer;\n\n$renderer = new PhpRenderer();\n\n$model    = new ViewModel();\n$model->setVariable('foo', 'bar');\n// or\n$model = new ViewModel(['foo' => 'bar']);\n\n$model->setTemplate($templateName);\n$renderer->render($model);\n\n\n\nNow, let's render something. As an example, let us say you have a list of\nbook data.\n\n\n// use a model to get the data for book authors and titles.\n$data = [\n    [\n        'author' => 'Hernando de Soto',\n        'title' => 'The Mystery of Capitalism',\n    ],\n    [\n        'author' => 'Henry Hazlitt',\n        'title' => 'Economics in One Lesson',\n    ],\n    [\n        'author' => 'Milton Friedman',\n        'title' => 'Free to Choose',\n    ],\n];\n\n// now assign the book data to a renderer instance\n$renderer->books = $data;\n\n// and render the template \"booklist\"\necho $renderer->render('booklist');\n\n\n\nMore often than not, you'll likely be using the MVC layer. As such, you should\nbe thinking in terms of view models. Let's consider the following code from\nwithin an action method of a controller.\n\n\nnamespace Bookstore\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass BookController extends AbstractActionController\n{\n    public function listAction()\n    {\n        // do some work...\n\n        // Assume $data is the list of books from the previous example\n        $model = new ViewModel(['books' => $data]);\n\n        // Optionally specify a template; if we don't, by default it will be\n        // auto-determined based on the module name, controller name and this action.\n        // In this example, the template would resolve to \"bookstore/book/list\",\n        // and thus the file \"bookstore/book/list.phtml\"; the following overrides\n        // that to set the template to \"booklist\", and thus the file \"booklist.phtml\"\n        // (note the lack of directory preceding the filename).\n        $model->setTemplate('booklist');\n\n        return $model\n    }\n}\n\n\n\nThis will then be rendered as if the following were executed:\n\n\n$renderer->render($model);\n\n\n\nNow we need the associated view script. At this point, we'll assume that the\ntemplate \nbooklist\n resolves to the file \nbooklist.phtml\n. This is a PHP script\nlike any other, with one exception: it executes inside the scope of the\n\nPhpRenderer\n instance, which means that references to \n$this\n point to the\n\nPhpRenderer\n instance properties and methods. Thus, a very basic view script\ncould look like this:\n\n\n<?php if ($this->books): ?>\n\n    <!-- A table of some books. -->\n    <table>\n        <tr>\n            <th>Author</th>\n            <th>Title</th>\n        </tr>\n\n        <?php foreach ($this->books as $key => $val): ?>\n        <tr>\n            <td><?= $this->escapeHtml($val['author']) ?></td>\n            <td><?= $this->escapeHtml($val['title']) ?></td>\n        </tr>\n        <?php endforeach; ?>\n\n    </table>\n\n<?php else: ?>\n\n    <p>There are no books to display.</p>\n\n<?php endif;?>\n\n\n\n\n\nEscape Output\n\n\nThe security mantra is \"Filter input, escape output.\" If you are unsure of the\nsource of a given variable \u2014 which is likely most of the time \u2014\nyou should escape it based on which HTML context it is being injected into.\nThe primary contexts to be aware of are HTML Body, HTML Attribute, Javascript,\nCSS and URI. Each context has a dedicated helper available to apply the\nescaping strategy most appropriate to each context. You should be aware that\nescaping does vary significantly between contexts; there is no one single\nescaping strategy that can be globally applied.  In the example above, there\nare calls to an \nescapeHtml()\n method. The method is actually\n\na helper\n, a plugin available via method overloading.\nAdditional escape helpers provide the \nescapeHtmlAttr()\n, \nescapeJs()\n,\n\nescapeCss()\n, and \nescapeUrl()\n methods for each of the HTML contexts you are\nmost likely to encounter. By using the provided helpers and being aware of\nyour variables' contexts, you will prevent your templates from running afoul\nof \nCross-Site Scripting (XSS)\n\nvulnerabilities.\n\n\n\n\nWe've now toured the basic usage of the \nPhpRenderer\n. By now you should know\nhow to instantiate the renderer, provide it with a resolver, assign variables\nand/or create view models, create view scripts, and render view scripts.\n\n\nOptions and Configuration\n\n\nZend\\View\\Renderer\\PhpRenderer\n utilizes several collaborators in order to do\nits work. Use the following methods to configure the renderer.\n\n\nUnless otherwise noted, class names are relative to the \nZend\\View\n namespace.\n\n\nsetHelperPluginManager\n\n\nsetHelperPluginManager(string|HelperPluginManager $helpers): void\n\n\n\nSet the helper plugin manager instance used to load, register, and retrieve\n\nhelpers\n.\n\n\nsetResolver\n\n\nsetResolver(Resolver\\\\ResolverInterface $resolver) : void\n\n\n\nSet the resolver instance.\n\n\nsetFilterChain\n\n\nsetFilterChain(\\Zend\\Filter\\FilterChain $filters) : void\n\n\n\nSet a filter chain to use as an output filter on rendered content.\n\n\nsetVars\n\n\nsetVars(array|\\ArrayAccess|Variables $variables) : void\n\n\n\nSet the variables to use when rendering a view script/template.\n\n\nsetCanRenderTrees\n\n\nsetCanRenderTrees(boolean $canRenderTrees) : void\n\n\n\nSet the flag indicating whether or not we should render trees of view models. If\nset to true, the \nZend\\View\\View\n instance will not attempt to render children\nseparately, but instead pass the root view model directly to the \nPhpRenderer\n.\nIt is then up to the developer to render the children from within the view\nscript. This is typically done using the \nRenderChildModel\n helper:\n\n$this->renderChildModel('child_name')\n.\n\n\nAdditional Methods\n\n\nTypically, you'll only ever access variables and \nhelpers\n\nwithin your view scripts or when interacting with the \nPhpRenderer\n. However,\nthere are a few additional methods you may be interested in.\n\n\nUnless otherwise noted, class names are relative to the \nZend\\View\n namespace.\n\n\nrender\n\n\nrender(\n    string|Model\\ModelInterface $nameOrModel,\n    array|\\Traversable $values = null\n) : string\n\n\n\nRender a template/view model.\n\n\nIf \n$nameOrModel\n is a string, it is assumed to be a template name. That\ntemplate will be resolved using the current resolver, and then rendered.\n\n\nIf \n$values\n is non-null, those values, and those values only, will be used\nduring rendering, and will replace whatever variable container previously was in\nthe renderer; however, the previous variable container will be reset when done.\n\n\nIf \n$values\n is empty, the current variables container (see \nsetVars()\n)\nwill be injected when rendering.\n\n\nIf \n$nameOrModel\n is a \nModelInterface\n instance, the template name will be\nretrieved from it and used.  Additionally, if the model contains any variables,\nthese will be used when rendering; otherwise, the variables container already\npresent, if any, will be used.\n\n\nThe method returns the script output.\n\n\nresolver\n\n\nresolver() : Resolver\\ResolverInterface\n\n\n\nRetrieves the current \nResolver\n instance.\n\n\nvars\n\n\nvars(string $key = null) : mixed\n\n\n\nRetrieve a single variable from the container if a key is provided; otherwise it\nwill return the variables container.\n\n\nplugin\n\n\nplugin(string $name, array $options = null) : Helper\\HelperInterface\n\n\n\nRetrieve a plugin/helper instance. Proxies to the plugin manager's \nget()\n\nmethod; as such, any \n$options\n you pass will be passed to the plugin's\nconstructor if this is the first time the plugin has been retrieved. See the\nsection on \nhelpers\n for more information.\n\n\naddTemplate\n\n\naddTemplate(string $template) : void\n\n\n\nAdd a template to the stack. When used, the next call to \nrender()\n will loop\nthrough all templates added using this method, rendering them one by one; the\noutput of the last will be returned.",
            "title": "The PhpRenderer"
        },
        {
            "location": "/php-renderer/#the-phprenderer",
            "text": "Zend\\View\\Renderer\\PhpRenderer  \"renders\" view scripts written in PHP,\ncapturing and returning the output. It composes Variable containers and/or View\nModels, a helper plugin manager for  helpers , and optional\nfiltering of the captured output.  The  PhpRenderer  is template-system agnostic; you may use PHP as your template\nlanguage, or create instances of other template systems and manipulate them\nwithin your view script. Anything you can do with PHP is available to you.",
            "title": "The PhpRenderer"
        },
        {
            "location": "/php-renderer/#usage",
            "text": "Basic usage consists of instantiating or otherwise obtaining an instance of the PhpRenderer , providing it with a resolver which will resolve templates to PHP\nview scripts, and then calling its  render()  method.  Instantiating a renderer:  use Zend\\View\\Renderer\\PhpRenderer;\n\n$renderer = new PhpRenderer();  zend-view ships with several types of \"resolvers\", which are used to resolve a\ntemplate name to a resource a renderer can consume. The ones we will usually use\nwith the  PhpRenderer  are:   Zend\\View\\Resolver\\TemplateMapResolver , which simply maps template names\n  directly to view scripts.  Zend\\View\\Resolver\\TemplatePathStack , which creates a LIFO stack of script\n  directories in which to search for a view script. By default, it appends the\n  suffix  .phtml  to the requested template name, and then loops through the\n  script directories; if it finds a file matching the requested template, it\n  returns the full file path.  Zend\\View\\Resolver\\RelativeFallbackResolver , which allows using short\n  template name into partial rendering. It is used as wrapper for each of two\n  aforesaid resolvers. For example, this allows usage of partial template paths\n  such as  my/module/script/path/my-view/some/partial.phtml , while rendering\n  template  my/module/script/path/my-view  by short name  some/partial .  Zend\\View\\Resolver\\AggregateResolver , which allows attaching a FIFO queue of\n  resolvers to consult.   We suggest using the  AggregateResolver , as it allows you to create a\nmulti-tiered strategy for resolving template names.  Programmatically, you would then do something like this:  use Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n$renderer = new PhpRenderer();\n\n$resolver = new Resolver\\AggregateResolver();\n\n$renderer->setResolver($resolver);\n\n$map = new Resolver\\TemplateMapResolver([\n    'layout'      => __DIR__ . '/view/layout.phtml',\n    'index/index' => __DIR__ . '/view/index/index.phtml',\n]);\n$stack = new Resolver\\TemplatePathStack([\n    'script_paths' => [\n        __DIR__ . '/view',\n        $someOtherPath\n    ],\n]);\n\n// Attach resolvers to the aggregate:\n$resolver\n    ->attach($map)    // this will be consulted first, and is the fastest lookup\n    ->attach($stack)  // filesystem-based lookup\n    ->attach(new Resolver\\RelativeFallbackResolver($map)) // allow short template names\n    ->attach(new Resolver\\RelativeFallbackResolver($stack));  You can also specify a specific priority value when registering resolvers, with\nhigh, positive integers getting higher priority, and low, negative integers\ngetting low priority, when resolving.  If you are started your application via the  skeleton\napplication , you can\nprovide the above via configuration:  // In the Application module configuration\n// (module/Application/config/module.config.php):\nreturn [\n    'view_manager' => [\n        'template_map' => [\n            'layout'      => __DIR__ . '/../view/layout.phtml',\n            'index/index' => __DIR__ . '/../view/index/index.phtml',\n        ],\n        'template_path_stack' => [\n            'application' => __DIR__ . '/../view',\n        ],\n    ],\n];  If you did not begin with the skeleton application, you will need to write your\nown factories for creating each resolver and wiring them to the AggregateResolver  and injecting into the  PhpRenderer .  Now that we have our  PhpRenderer  instance, and it can find templates, let's\ninject some variables. This can be done in 4 different ways.   Pass an associative array (or  ArrayAccess  instance, or  Zend\\View\\Variables \n  instance) of items as the second argument to  render() :\n   $renderer->render($templateName, array('foo' =&gt; 'bar))  Assign a  Zend\\View\\Variables  instance, associative array, or  ArrayAccess \n  instance to the  setVars()  method.  Assign variables as instance properties of the renderer:  $renderer->foo =\n  'bar' . This essentially proxies to an instance of  Variables  composed\n  internally in the renderer by default.  Create a  ViewModel  instance, assign variables to that, and pass the\n   ViewModel  to the  render()  method:   As an example of the latter:  use Zend\\View\\Model\\ViewModel;\nuse Zend\\View\\Renderer\\PhpRenderer;\n\n$renderer = new PhpRenderer();\n\n$model    = new ViewModel();\n$model->setVariable('foo', 'bar');\n// or\n$model = new ViewModel(['foo' => 'bar']);\n\n$model->setTemplate($templateName);\n$renderer->render($model);  Now, let's render something. As an example, let us say you have a list of\nbook data.  // use a model to get the data for book authors and titles.\n$data = [\n    [\n        'author' => 'Hernando de Soto',\n        'title' => 'The Mystery of Capitalism',\n    ],\n    [\n        'author' => 'Henry Hazlitt',\n        'title' => 'Economics in One Lesson',\n    ],\n    [\n        'author' => 'Milton Friedman',\n        'title' => 'Free to Choose',\n    ],\n];\n\n// now assign the book data to a renderer instance\n$renderer->books = $data;\n\n// and render the template \"booklist\"\necho $renderer->render('booklist');  More often than not, you'll likely be using the MVC layer. As such, you should\nbe thinking in terms of view models. Let's consider the following code from\nwithin an action method of a controller.  namespace Bookstore\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass BookController extends AbstractActionController\n{\n    public function listAction()\n    {\n        // do some work...\n\n        // Assume $data is the list of books from the previous example\n        $model = new ViewModel(['books' => $data]);\n\n        // Optionally specify a template; if we don't, by default it will be\n        // auto-determined based on the module name, controller name and this action.\n        // In this example, the template would resolve to \"bookstore/book/list\",\n        // and thus the file \"bookstore/book/list.phtml\"; the following overrides\n        // that to set the template to \"booklist\", and thus the file \"booklist.phtml\"\n        // (note the lack of directory preceding the filename).\n        $model->setTemplate('booklist');\n\n        return $model\n    }\n}  This will then be rendered as if the following were executed:  $renderer->render($model);  Now we need the associated view script. At this point, we'll assume that the\ntemplate  booklist  resolves to the file  booklist.phtml . This is a PHP script\nlike any other, with one exception: it executes inside the scope of the PhpRenderer  instance, which means that references to  $this  point to the PhpRenderer  instance properties and methods. Thus, a very basic view script\ncould look like this:  <?php if ($this->books): ?>\n\n    <!-- A table of some books. -->\n    <table>\n        <tr>\n            <th>Author</th>\n            <th>Title</th>\n        </tr>\n\n        <?php foreach ($this->books as $key => $val): ?>\n        <tr>\n            <td><?= $this->escapeHtml($val['author']) ?></td>\n            <td><?= $this->escapeHtml($val['title']) ?></td>\n        </tr>\n        <?php endforeach; ?>\n\n    </table>\n\n<?php else: ?>\n\n    <p>There are no books to display.</p>\n\n<?php endif;?>",
            "title": "Usage"
        },
        {
            "location": "/php-renderer/#escape-output",
            "text": "The security mantra is \"Filter input, escape output.\" If you are unsure of the\nsource of a given variable \u2014 which is likely most of the time \u2014\nyou should escape it based on which HTML context it is being injected into.\nThe primary contexts to be aware of are HTML Body, HTML Attribute, Javascript,\nCSS and URI. Each context has a dedicated helper available to apply the\nescaping strategy most appropriate to each context. You should be aware that\nescaping does vary significantly between contexts; there is no one single\nescaping strategy that can be globally applied.  In the example above, there\nare calls to an  escapeHtml()  method. The method is actually a helper , a plugin available via method overloading.\nAdditional escape helpers provide the  escapeHtmlAttr() ,  escapeJs() , escapeCss() , and  escapeUrl()  methods for each of the HTML contexts you are\nmost likely to encounter. By using the provided helpers and being aware of\nyour variables' contexts, you will prevent your templates from running afoul\nof  Cross-Site Scripting (XSS) \nvulnerabilities.   We've now toured the basic usage of the  PhpRenderer . By now you should know\nhow to instantiate the renderer, provide it with a resolver, assign variables\nand/or create view models, create view scripts, and render view scripts.",
            "title": "Escape Output"
        },
        {
            "location": "/php-renderer/#options-and-configuration",
            "text": "Zend\\View\\Renderer\\PhpRenderer  utilizes several collaborators in order to do\nits work. Use the following methods to configure the renderer.  Unless otherwise noted, class names are relative to the  Zend\\View  namespace.",
            "title": "Options and Configuration"
        },
        {
            "location": "/php-renderer/#sethelperpluginmanager",
            "text": "setHelperPluginManager(string|HelperPluginManager $helpers): void  Set the helper plugin manager instance used to load, register, and retrieve helpers .",
            "title": "setHelperPluginManager"
        },
        {
            "location": "/php-renderer/#setresolver",
            "text": "setResolver(Resolver\\\\ResolverInterface $resolver) : void  Set the resolver instance.",
            "title": "setResolver"
        },
        {
            "location": "/php-renderer/#setfilterchain",
            "text": "setFilterChain(\\Zend\\Filter\\FilterChain $filters) : void  Set a filter chain to use as an output filter on rendered content.",
            "title": "setFilterChain"
        },
        {
            "location": "/php-renderer/#setvars",
            "text": "setVars(array|\\ArrayAccess|Variables $variables) : void  Set the variables to use when rendering a view script/template.",
            "title": "setVars"
        },
        {
            "location": "/php-renderer/#setcanrendertrees",
            "text": "setCanRenderTrees(boolean $canRenderTrees) : void  Set the flag indicating whether or not we should render trees of view models. If\nset to true, the  Zend\\View\\View  instance will not attempt to render children\nseparately, but instead pass the root view model directly to the  PhpRenderer .\nIt is then up to the developer to render the children from within the view\nscript. This is typically done using the  RenderChildModel  helper: $this->renderChildModel('child_name') .",
            "title": "setCanRenderTrees"
        },
        {
            "location": "/php-renderer/#additional-methods",
            "text": "Typically, you'll only ever access variables and  helpers \nwithin your view scripts or when interacting with the  PhpRenderer . However,\nthere are a few additional methods you may be interested in.  Unless otherwise noted, class names are relative to the  Zend\\View  namespace.",
            "title": "Additional Methods"
        },
        {
            "location": "/php-renderer/#render",
            "text": "render(\n    string|Model\\ModelInterface $nameOrModel,\n    array|\\Traversable $values = null\n) : string  Render a template/view model.  If  $nameOrModel  is a string, it is assumed to be a template name. That\ntemplate will be resolved using the current resolver, and then rendered.  If  $values  is non-null, those values, and those values only, will be used\nduring rendering, and will replace whatever variable container previously was in\nthe renderer; however, the previous variable container will be reset when done.  If  $values  is empty, the current variables container (see  setVars() )\nwill be injected when rendering.  If  $nameOrModel  is a  ModelInterface  instance, the template name will be\nretrieved from it and used.  Additionally, if the model contains any variables,\nthese will be used when rendering; otherwise, the variables container already\npresent, if any, will be used.  The method returns the script output.",
            "title": "render"
        },
        {
            "location": "/php-renderer/#resolver",
            "text": "resolver() : Resolver\\ResolverInterface  Retrieves the current  Resolver  instance.",
            "title": "resolver"
        },
        {
            "location": "/php-renderer/#vars",
            "text": "vars(string $key = null) : mixed  Retrieve a single variable from the container if a key is provided; otherwise it\nwill return the variables container.",
            "title": "vars"
        },
        {
            "location": "/php-renderer/#plugin",
            "text": "plugin(string $name, array $options = null) : Helper\\HelperInterface  Retrieve a plugin/helper instance. Proxies to the plugin manager's  get() \nmethod; as such, any  $options  you pass will be passed to the plugin's\nconstructor if this is the first time the plugin has been retrieved. See the\nsection on  helpers  for more information.",
            "title": "plugin"
        },
        {
            "location": "/php-renderer/#addtemplate",
            "text": "addTemplate(string $template) : void  Add a template to the stack. When used, the next call to  render()  will loop\nthrough all templates added using this method, rendering them one by one; the\noutput of the last will be returned.",
            "title": "addTemplate"
        },
        {
            "location": "/view-scripts/",
            "text": "View Scripts\n\n\nOnce you call \nrender()\n, \nZend\\View\\Renderer\\PhpRenderer\n then \ninclude()\ns the\nrequested view script and executes it \"inside\" the scope of the \nPhpRenderer\n\ninstance. Therefore, in your view scripts, references to \n$this\n actually point\nto the \nPhpRenderer\n instance itself.\n\n\nVariables assigned to the view, either via a \nView Model\n,\n\nVariables container\n, or by passing an array of variables to\n\nrender()\n, may be retrieved in three ways:\n\n\n\n\nExplicitly, by retrieving them from the \nVariables\n container composed in the\n  \nPhpRenderer\n: \n$this->vars()->varname\n.\n\n\nAs instance properties of the \nPhpRenderer\n instance: \n$this->varname\n. (In\n  this situation, instance property access is proxying to the composed\n  \nVariables\n instance.)\n\n\nAs local PHP variables: \n$varname\n. The \nPhpRenderer\n extracts the members of\n  the \nVariables\n container locally.\n\n\n\n\nWe generally recommend using the second notation, as it's less verbose than the\nfirst, but differentiates between variables in the view script scope and those\nassigned to the renderer from elsewhere.\n\n\nBy way of reminder, here is the example view script from the \nPhpRenderer\n\nintroduction.\n\n\n<?php if ($this->books): ?>\n\n    <!-- A table of some books. -->\n    <table>\n        <tr>\n            <th>Author</th>\n            <th>Title</th>\n        </tr>\n\n        <?php foreach ($this->books as $key => $val): ?>\n        <tr>\n            <td><?= $this->escapeHtml($val['author']) ?></td>\n            <td><?= $this->escapeHtml($val['title']) ?></td>\n        </tr>\n        <?php endforeach; ?>\n\n    </table>\n\n<?php else: ?>\n\n    <p>There are no books to display.</p>\n\n<?php endif;?>\n\n\n\nEscaping Output\n\n\nOne of the most important tasks to perform in a view script is to make sure that\noutput is escaped properly; among other things, this helps to avoid cross-site\nscripting attacks. Unless you are using a function, method, or helper that does\nescaping on its own, you should always escape variables when you output them and\npay careful attention to applying the correct escaping strategy to each HTML\ncontext you use.\n\n\nThe \nPhpRenderer\n includes a selection of helpers you can use for this purpose:\n\nEscapeHtml\n, \nEscapeHtmlAttr\n, \nEscapeJs\n, \nEscapeCss\n, and \nEscapeUrl\n.\nMatching the correct helper (or combination of helpers) to the context into\nwhich you are injecting untrusted variables will ensure that you are protected\nagainst Cross-Site Scripting (XSS) vulnerabilities.\n\n\n// bad view-script practice:\necho $this->variable;\n\n// good view-script practice:\necho $this->escapeHtml($this->variable);\n\n// and remember context is always relevant!\n<script type=\"text/javascript\">\n    var foo = \"<?= $this->escapeJs($variable) ?>\";\n</script>",
            "title": "View Scripts"
        },
        {
            "location": "/view-scripts/#view-scripts",
            "text": "Once you call  render() ,  Zend\\View\\Renderer\\PhpRenderer  then  include() s the\nrequested view script and executes it \"inside\" the scope of the  PhpRenderer \ninstance. Therefore, in your view scripts, references to  $this  actually point\nto the  PhpRenderer  instance itself.  Variables assigned to the view, either via a  View Model , Variables container , or by passing an array of variables to render() , may be retrieved in three ways:   Explicitly, by retrieving them from the  Variables  container composed in the\n   PhpRenderer :  $this->vars()->varname .  As instance properties of the  PhpRenderer  instance:  $this->varname . (In\n  this situation, instance property access is proxying to the composed\n   Variables  instance.)  As local PHP variables:  $varname . The  PhpRenderer  extracts the members of\n  the  Variables  container locally.   We generally recommend using the second notation, as it's less verbose than the\nfirst, but differentiates between variables in the view script scope and those\nassigned to the renderer from elsewhere.  By way of reminder, here is the example view script from the  PhpRenderer \nintroduction.  <?php if ($this->books): ?>\n\n    <!-- A table of some books. -->\n    <table>\n        <tr>\n            <th>Author</th>\n            <th>Title</th>\n        </tr>\n\n        <?php foreach ($this->books as $key => $val): ?>\n        <tr>\n            <td><?= $this->escapeHtml($val['author']) ?></td>\n            <td><?= $this->escapeHtml($val['title']) ?></td>\n        </tr>\n        <?php endforeach; ?>\n\n    </table>\n\n<?php else: ?>\n\n    <p>There are no books to display.</p>\n\n<?php endif;?>",
            "title": "View Scripts"
        },
        {
            "location": "/view-scripts/#escaping-output",
            "text": "One of the most important tasks to perform in a view script is to make sure that\noutput is escaped properly; among other things, this helps to avoid cross-site\nscripting attacks. Unless you are using a function, method, or helper that does\nescaping on its own, you should always escape variables when you output them and\npay careful attention to applying the correct escaping strategy to each HTML\ncontext you use.  The  PhpRenderer  includes a selection of helpers you can use for this purpose: EscapeHtml ,  EscapeHtmlAttr ,  EscapeJs ,  EscapeCss , and  EscapeUrl .\nMatching the correct helper (or combination of helpers) to the context into\nwhich you are injecting untrusted variables will ensure that you are protected\nagainst Cross-Site Scripting (XSS) vulnerabilities.  // bad view-script practice:\necho $this->variable;\n\n// good view-script practice:\necho $this->escapeHtml($this->variable);\n\n// and remember context is always relevant!\n<script type=\"text/javascript\">\n    var foo = \"<?= $this->escapeJs($variable) ?>\";\n</script>",
            "title": "Escaping Output"
        },
        {
            "location": "/view-event/",
            "text": "The ViewEvent\n\n\nzend-view incorporates and utilizes a custom \nzend-eventmanager\nEvent\n implementation,\n\nZend\\View\\ViewEvent\n. This event is created during \nZend\\View\\View::getEvent()\n\nand is passed directly to all the events the \nView\n class triggers.\n\n\nThe \nViewEvent\n adds accessors and mutators for the following:\n\n\n\n\nModel\n object, typically representing the layout view model.\n\n\nRenderer\n object.\n\n\nRequest\n object.\n\n\nResponse\n object.\n\n\nResult\n (typically a string representing the rendered content).\n\n\n\n\nThe methods it defines are:\n\n\n\n\nsetModel(Model $model)\n\n\ngetModel()\n\n\nsetRequest($request)\n\n\ngetRequest()\n\n\nsetResponse($response)\n\n\ngetResponse()\n\n\nsetRenderer($renderer)\n\n\ngetRenderer()\n\n\nsetResult($result)\n\n\ngetResult()\n\n\n\n\nOrder of events\n\n\nThe following events are triggered, in the following order:\n\n\n\n\n\n\n\n\nName\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrenderer\n\n\nViewEvent::EVENT_RENDERER\n\n\nRender the view, with the help of renderers.\n\n\n\n\n\n\nrenderer.post\n\n\nViewEvent::EVENT_RENDERER_POST\n\n\nTriggers after the view is rendered.\n\n\n\n\n\n\nresponse\n\n\nViewEvent::EVENT_RESPONSE\n\n\nPopulate the response from the view.\n\n\n\n\n\n\n\n\nEach is described in the following sections.\n\n\nViewEvent::EVENT_RENDERER\n\n\nListeners\n\n\nThe following classes are listening to this event (they are sorted from higher priority to lower\npriority):\n\n\nFor PhpStrategy\n\n\nThis listener is added when the strategy used for rendering is \nPhpStrategy\n:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\Strategy\\PhpStrategy\n\n\n1\n\n\nselectRenderer\n\n\nReturn a \nPhpRenderer\n\n\n\n\n\n\n\n\nFor JsonStrategy\n\n\nThis listener is added when the strategy used for rendering is \nJsonStrategy\n:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\Strategy\\JsonStrategy\n\n\n1\n\n\nselectRenderer\n\n\nReturn a \nJsonRenderer\n\n\n\n\n\n\n\n\nFor FeedStrategy\n\n\nThis listener is added when the strategy used for rendering is \nFeedStrategy\n:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\Strategy\\FeedStrategy\n\n\n1\n\n\nselectRenderer\n\n\nReturn a \nFeedRenderer\n\n\n\n\n\n\n\n\nTriggerers\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\View\n\n\nrender\n\n\nIt has a short circuit callback that stops propagation once one result return an instance of a Renderer.\n\n\n\n\n\n\n\n\nViewEvent::EVENT_RENDERER_POST\n\n\nListeners\n\n\nThere are currently no built-in listeners for this event.\n\n\nTriggerers\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\View\n\n\nrender\n\n\nThis event is triggered after \nViewEvent::EVENT_RENDERER\n and before \nViewEvent::EVENT_RESPONSE\n.\n\n\n\n\n\n\n\n\nViewEvent::EVENT_RESPONSE\n\n\nListeners\n\n\nThe following classes are listening to this event (they are sorted from higher priority to lower\npriority):\n\n\nFor PhpStrategy\n\n\nThis listener is added when the strategy used for rendering is \nPhpStrategy\n:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\Strategy\\PhpStrategy\n\n\n1\n\n\ninjectResponse\n\n\nPopulate the \nResponse\n object from the rendered view.\n\n\n\n\n\n\n\n\nFor JsonStrategy\n\n\nThis listener is added when the strategy used for rendering is \nJsonStrategy\n:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\Strategy\\JsonStrategy\n\n\n1\n\n\ninjectResponse\n\n\nPopulate the \nResponse\n object with the serialized JSON content.\n\n\n\n\n\n\n\n\nFor FeedStrategy\n\n\nThis listener is added when the strategy used for rendering is \nFeedStrategy\n:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\Strategy\\FeedStrategy\n\n\n1\n\n\ninjectResponse\n\n\nPopulate the \nResponse\n object with the rendered feed.\n\n\n\n\n\n\n\n\nTriggerers\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\View\\View\n\n\nrender\n\n\nThis event is triggered after \nViewEvent::EVENT_RENDERER\n and \nViewEvent::EVENT_RENDERER_POST\n.",
            "title": "The ViewEvent"
        },
        {
            "location": "/view-event/#the-viewevent",
            "text": "zend-view incorporates and utilizes a custom  zend-eventmanager\nEvent  implementation, Zend\\View\\ViewEvent . This event is created during  Zend\\View\\View::getEvent() \nand is passed directly to all the events the  View  class triggers.  The  ViewEvent  adds accessors and mutators for the following:   Model  object, typically representing the layout view model.  Renderer  object.  Request  object.  Response  object.  Result  (typically a string representing the rendered content).   The methods it defines are:   setModel(Model $model)  getModel()  setRequest($request)  getRequest()  setResponse($response)  getResponse()  setRenderer($renderer)  getRenderer()  setResult($result)  getResult()",
            "title": "The ViewEvent"
        },
        {
            "location": "/view-event/#order-of-events",
            "text": "The following events are triggered, in the following order:     Name  Constant  Description      renderer  ViewEvent::EVENT_RENDERER  Render the view, with the help of renderers.    renderer.post  ViewEvent::EVENT_RENDERER_POST  Triggers after the view is rendered.    response  ViewEvent::EVENT_RESPONSE  Populate the response from the view.     Each is described in the following sections.",
            "title": "Order of events"
        },
        {
            "location": "/view-event/#vieweventevent95renderer",
            "text": "",
            "title": "ViewEvent::EVENT_RENDERER"
        },
        {
            "location": "/view-event/#listeners",
            "text": "The following classes are listening to this event (they are sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/view-event/#for-phpstrategy",
            "text": "This listener is added when the strategy used for rendering is  PhpStrategy :     Class  Priority  Method called  Description      Zend\\View\\Strategy\\PhpStrategy  1  selectRenderer  Return a  PhpRenderer",
            "title": "For PhpStrategy"
        },
        {
            "location": "/view-event/#for-jsonstrategy",
            "text": "This listener is added when the strategy used for rendering is  JsonStrategy :     Class  Priority  Method called  Description      Zend\\View\\Strategy\\JsonStrategy  1  selectRenderer  Return a  JsonRenderer",
            "title": "For JsonStrategy"
        },
        {
            "location": "/view-event/#for-feedstrategy",
            "text": "This listener is added when the strategy used for rendering is  FeedStrategy :     Class  Priority  Method called  Description      Zend\\View\\Strategy\\FeedStrategy  1  selectRenderer  Return a  FeedRenderer",
            "title": "For FeedStrategy"
        },
        {
            "location": "/view-event/#triggerers",
            "text": "This event is triggered by the following classes:     Class  In method  Description      Zend\\View\\View  render  It has a short circuit callback that stops propagation once one result return an instance of a Renderer.",
            "title": "Triggerers"
        },
        {
            "location": "/view-event/#vieweventevent95renderer95post",
            "text": "",
            "title": "ViewEvent::EVENT_RENDERER_POST"
        },
        {
            "location": "/view-event/#listeners_1",
            "text": "There are currently no built-in listeners for this event.",
            "title": "Listeners"
        },
        {
            "location": "/view-event/#triggerers_1",
            "text": "This event is triggered by the following classes:     Class  In method  Description      Zend\\View\\View  render  This event is triggered after  ViewEvent::EVENT_RENDERER  and before  ViewEvent::EVENT_RESPONSE .",
            "title": "Triggerers"
        },
        {
            "location": "/view-event/#vieweventevent95response",
            "text": "",
            "title": "ViewEvent::EVENT_RESPONSE"
        },
        {
            "location": "/view-event/#listeners_2",
            "text": "The following classes are listening to this event (they are sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/view-event/#for-phpstrategy_1",
            "text": "This listener is added when the strategy used for rendering is  PhpStrategy :     Class  Priority  Method called  Description      Zend\\View\\Strategy\\PhpStrategy  1  injectResponse  Populate the  Response  object from the rendered view.",
            "title": "For PhpStrategy"
        },
        {
            "location": "/view-event/#for-jsonstrategy_1",
            "text": "This listener is added when the strategy used for rendering is  JsonStrategy :     Class  Priority  Method called  Description      Zend\\View\\Strategy\\JsonStrategy  1  injectResponse  Populate the  Response  object with the serialized JSON content.",
            "title": "For JsonStrategy"
        },
        {
            "location": "/view-event/#for-feedstrategy_1",
            "text": "This listener is added when the strategy used for rendering is  FeedStrategy :     Class  Priority  Method called  Description      Zend\\View\\Strategy\\FeedStrategy  1  injectResponse  Populate the  Response  object with the rendered feed.",
            "title": "For FeedStrategy"
        },
        {
            "location": "/view-event/#triggerers_2",
            "text": "This event is triggered by the following classes:     Class  In method  Description      Zend\\View\\View  render  This event is triggered after  ViewEvent::EVENT_RENDERER  and  ViewEvent::EVENT_RENDERER_POST .",
            "title": "Triggerers"
        },
        {
            "location": "/helpers/intro/",
            "text": "View Helpers\n\n\nIn your view scripts, you'll perform certain complex functions over and over:\ne.g., formatting a date, generating form elements, or displaying action links.\nYou can use helper, or plugin, classes to perform these behaviors for you.\n\n\nA helper is a class that implements \nZend\\View\\Helper\\HelperInterface\n, which\ndefines two methods, \nsetView()\n, which accepts a\n\nZend\\View\\Renderer\\RendererInterface\n instance/implementation, and \ngetView()\n,\nused to retrieve that instance.  \nZend\\View\\Renderer\\PhpRenderer\n composes a\n\nplugin manager\n, allowing you to retrieve helpers, and also provides some\nmethod overloading capabilities that allow proxying method calls to helpers.\n\n\n\n\nCallable helpers\n\n\nStarting in version 2.7.0, if your helper does not need access to the view,\nyou can also use any PHP callable as a helper, including arbitrary objects\nthat implement \n__invoke()\n.\n\n\n\n\nAs an example, let's say we have a helper class named\n\nMyModule\\View\\Helper\\LowerCase\n, which we register in our plugin manager with\nthe name \nlowercase\n. We can retrieve it in one of the following ways:\n\n\n// $view is a PhpRenderer instance\n\n// Via the plugin manager:\n$pluginManager = $view->getHelperPluginManager();\n$helper        = $pluginManager->get('lowercase');\n\n// Retrieve the helper instance, via the method \"plugin\",\n// which proxies to the plugin manager:\n$helper = $view->plugin('lowercase');\n\n// If the helper does not define __invoke(), the following also retrieves it:\n$helper = $view->lowercase();\n\n// If the helper DOES define __invoke, you can call the helper\n// as if it is a method:\n$filtered = $view->lowercase('some value');\n\n\n\nThe last two examples demonstrate how the \nPhpRenderer\n uses method overloading\nto retrieve and/or invoke helpers directly, offering a convenience API for end\nusers.\n\n\nA large number of helpers are provided by default with zend-view.  You can also\nregister helpers by adding them to the plugin manager.\n\n\nIncluded Helpers\n\n\nZend Framework comes with an initial set of helper classes. In particular, there\nare helpers for creating route-based URLs and HTML lists, as well as declaring\nvariables. Additionally, there are a rich set of helpers for providing values\nfor, and rendering, the various HTML \n<head>\n tags, such as \nHeadTitle\n,\n\nHeadLink\n, and \nHeadScript\n. The currently shipped helpers include:\n\n\n\n\nAsset\n\n\nBasePath\n\n\nCycle\n\n\nDoctype\n\n\nFlashMessenger\n\n\nGravatar\n\n\nHeadLink\n\n\nHeadMeta\n\n\nHeadScript\n\n\nHeadStyle\n\n\nHeadTitle\n\n\nHtmlList\n\n\nHTML Object Plugins\n\n\nIdentity\n\n\nInlineScript\n\n\nJSON\n\n\nLayout\n\n\nPartial\n\n\nPlaceholder\n\n\nUrl\n\n\n\n\n\n\nHelp document!\n\n\nNot all helpers are documented! Some that could use documentation include the\nvarious escaper helpers, the layout helper, and the \nserverUrl\n helper. Click\nthe \"GitHub\" octocat link in the top navbar to go to the repository and start\nwriting documentation!\n\n\ni18n helpers\n\n\nView helpers related to \nInternationalization\n are documented in the\n\nI18n View Helpers\n\ndocumentation.\n\n\nForm helpers\n\n\nView helpers related to \nform\n are documented in the\n\nForm View Helpers\n\ndocumentation.\n\n\nNavigation helpers\n\n\nView helpers related to \nnavigation\n are documented in the\n\nNavigation View Helpers\n\ndocumentation.\n\n\nPagination helpers\n\n\nView helpers related to \npaginator\n are documented in the\n\nPaginator Usage\n\ndocumentation.\n\n\nCustom helpers\n\n\nFor documentation on writing \ncustom view helpers\n see the\n\nAdvanced usage\n chapter.",
            "title": "Intro"
        },
        {
            "location": "/helpers/intro/#view-helpers",
            "text": "In your view scripts, you'll perform certain complex functions over and over:\ne.g., formatting a date, generating form elements, or displaying action links.\nYou can use helper, or plugin, classes to perform these behaviors for you.  A helper is a class that implements  Zend\\View\\Helper\\HelperInterface , which\ndefines two methods,  setView() , which accepts a Zend\\View\\Renderer\\RendererInterface  instance/implementation, and  getView() ,\nused to retrieve that instance.   Zend\\View\\Renderer\\PhpRenderer  composes a plugin manager , allowing you to retrieve helpers, and also provides some\nmethod overloading capabilities that allow proxying method calls to helpers.",
            "title": "View Helpers"
        },
        {
            "location": "/helpers/intro/#callable-helpers",
            "text": "Starting in version 2.7.0, if your helper does not need access to the view,\nyou can also use any PHP callable as a helper, including arbitrary objects\nthat implement  __invoke() .   As an example, let's say we have a helper class named MyModule\\View\\Helper\\LowerCase , which we register in our plugin manager with\nthe name  lowercase . We can retrieve it in one of the following ways:  // $view is a PhpRenderer instance\n\n// Via the plugin manager:\n$pluginManager = $view->getHelperPluginManager();\n$helper        = $pluginManager->get('lowercase');\n\n// Retrieve the helper instance, via the method \"plugin\",\n// which proxies to the plugin manager:\n$helper = $view->plugin('lowercase');\n\n// If the helper does not define __invoke(), the following also retrieves it:\n$helper = $view->lowercase();\n\n// If the helper DOES define __invoke, you can call the helper\n// as if it is a method:\n$filtered = $view->lowercase('some value');  The last two examples demonstrate how the  PhpRenderer  uses method overloading\nto retrieve and/or invoke helpers directly, offering a convenience API for end\nusers.  A large number of helpers are provided by default with zend-view.  You can also\nregister helpers by adding them to the plugin manager.",
            "title": "Callable helpers"
        },
        {
            "location": "/helpers/intro/#included-helpers",
            "text": "Zend Framework comes with an initial set of helper classes. In particular, there\nare helpers for creating route-based URLs and HTML lists, as well as declaring\nvariables. Additionally, there are a rich set of helpers for providing values\nfor, and rendering, the various HTML  <head>  tags, such as  HeadTitle , HeadLink , and  HeadScript . The currently shipped helpers include:   Asset  BasePath  Cycle  Doctype  FlashMessenger  Gravatar  HeadLink  HeadMeta  HeadScript  HeadStyle  HeadTitle  HtmlList  HTML Object Plugins  Identity  InlineScript  JSON  Layout  Partial  Placeholder  Url",
            "title": "Included Helpers"
        },
        {
            "location": "/helpers/intro/#help-document",
            "text": "Not all helpers are documented! Some that could use documentation include the\nvarious escaper helpers, the layout helper, and the  serverUrl  helper. Click\nthe \"GitHub\" octocat link in the top navbar to go to the repository and start\nwriting documentation!",
            "title": "Help document!"
        },
        {
            "location": "/helpers/intro/#i18n-helpers",
            "text": "View helpers related to  Internationalization  are documented in the I18n View Helpers \ndocumentation.",
            "title": "i18n helpers"
        },
        {
            "location": "/helpers/intro/#form-helpers",
            "text": "View helpers related to  form  are documented in the Form View Helpers \ndocumentation.",
            "title": "Form helpers"
        },
        {
            "location": "/helpers/intro/#navigation-helpers",
            "text": "View helpers related to  navigation  are documented in the Navigation View Helpers \ndocumentation.",
            "title": "Navigation helpers"
        },
        {
            "location": "/helpers/intro/#pagination-helpers",
            "text": "View helpers related to  paginator  are documented in the Paginator Usage \ndocumentation.",
            "title": "Pagination helpers"
        },
        {
            "location": "/helpers/intro/#custom-helpers",
            "text": "For documentation on writing  custom view helpers  see the Advanced usage  chapter.",
            "title": "Custom helpers"
        },
        {
            "location": "/helpers/asset/",
            "text": "Asset\n\n\nThe \nAsset\n helper is used to map asset names to versioned assets.\n\n\nThis can be used to allow using a single, canonical name for an asset within\nyour view scripts, while having that map to:\n\n\n\n\nA versioned asset name, used to prevent browser caching.\n\n\nA product of a build process (such as a CSS pre-processor, JS compiler, etc.)\n\n\n\n\nConfiguration and Basic Usage\n\n\nZend\\View\\Helper\\Service\\AssetFactory\n checks the application configuration,\nmaking it possible to set up the resource map through your \nmodule.config.php\n\nor application configuration. As an example:\n\n\n'view_helper_config' => [\n    'asset' => [\n        'resource_map' => [\n            'css/style.css' => 'css/style-3a97ff4ee3.css',\n            'js/vendor.js' => 'js/vendor-a507086eba.js',\n        ],\n    ],\n],\n\n\n\nWithin your view script, you would reference the asset name:\n\n\n// Usable in any of your .phtml files:\necho $this->asset('css/style.css');\n\n\n\nwhich then emits the following output:\n\n\ncss/style-3a97ff4ee3.css\n\n\n\nThe first argument of the \nasset\n helper is the regular asset name, which will\nbe replaced by the associated value defined in the \nresource_map\n of the\nconfiguration.\n\n\n\n\nExceptions\n\n\nWhen an \nasset\n key is specified but the \nresource_map\n is not provided or is not\nan array, the helper will raise a \nZend\\View\\Exception\\RuntimeException\n.\n\n\nWhen you call the \nasset\n helper with a parameter not defined in your\n\nresource_map\n, the helper will raise a \nZend\\View\\Exception\\InvalidArgumentException\n.\n\n\n\n\nResource map in JSON file\n\n\nA number of build tools, such as gulp-rev and grunt-rev, will create a JSON\nresource map file such as \nrev-manifest.json\n:\n\n\n{\n    \"css/style.css\": \"css/style-3a97ff4ee3.css\",\n    \"js/vendor.js\": \"js/vendor-a507086eba.js\"\n}\n\n\n\nYou can incorporate these into your configuration manually by fetching and\ndecoding the contents:\n\n\n'view_helper_config' => [\n    'asset' => [\n        'resource_map' => json_decode(file_get_contents('path/to/rev-manifest.json'), true),\n    ],\n],\n\n\n\nIf you have enabled configuration caching, these values \nwill also be cached\n,\nmeaning that the above operation will occur exactly once in your production\nconfiguration.",
            "title": "Asset"
        },
        {
            "location": "/helpers/asset/#asset",
            "text": "The  Asset  helper is used to map asset names to versioned assets.  This can be used to allow using a single, canonical name for an asset within\nyour view scripts, while having that map to:   A versioned asset name, used to prevent browser caching.  A product of a build process (such as a CSS pre-processor, JS compiler, etc.)",
            "title": "Asset"
        },
        {
            "location": "/helpers/asset/#configuration-and-basic-usage",
            "text": "Zend\\View\\Helper\\Service\\AssetFactory  checks the application configuration,\nmaking it possible to set up the resource map through your  module.config.php \nor application configuration. As an example:  'view_helper_config' => [\n    'asset' => [\n        'resource_map' => [\n            'css/style.css' => 'css/style-3a97ff4ee3.css',\n            'js/vendor.js' => 'js/vendor-a507086eba.js',\n        ],\n    ],\n],  Within your view script, you would reference the asset name:  // Usable in any of your .phtml files:\necho $this->asset('css/style.css');  which then emits the following output:  css/style-3a97ff4ee3.css  The first argument of the  asset  helper is the regular asset name, which will\nbe replaced by the associated value defined in the  resource_map  of the\nconfiguration.",
            "title": "Configuration and Basic Usage"
        },
        {
            "location": "/helpers/asset/#exceptions",
            "text": "When an  asset  key is specified but the  resource_map  is not provided or is not\nan array, the helper will raise a  Zend\\View\\Exception\\RuntimeException .  When you call the  asset  helper with a parameter not defined in your resource_map , the helper will raise a  Zend\\View\\Exception\\InvalidArgumentException .",
            "title": "Exceptions"
        },
        {
            "location": "/helpers/asset/#resource-map-in-json-file",
            "text": "A number of build tools, such as gulp-rev and grunt-rev, will create a JSON\nresource map file such as  rev-manifest.json :  {\n    \"css/style.css\": \"css/style-3a97ff4ee3.css\",\n    \"js/vendor.js\": \"js/vendor-a507086eba.js\"\n}  You can incorporate these into your configuration manually by fetching and\ndecoding the contents:  'view_helper_config' => [\n    'asset' => [\n        'resource_map' => json_decode(file_get_contents('path/to/rev-manifest.json'), true),\n    ],\n],  If you have enabled configuration caching, these values  will also be cached ,\nmeaning that the above operation will occur exactly once in your production\nconfiguration.",
            "title": "Resource map in JSON file"
        },
        {
            "location": "/helpers/base-path/",
            "text": "BasePath\n\n\nWhile most URLs generated by the framework have the base URL prepended\nautomatically, developers will need to prepend the base URL to their own URLs\n(usually inside an \nhref\n attribute) in order for paths to resources to be\ncorrect.\n\n\nIf you're running a zend-mvc application, \nbasePath()\n will point to the\n\npublic\n folder of the application's root.\n\n\nBasic Usage\n\n\n/*\n * The following assume that the base URL of the page/application is \"/mypage\".\n */\n\n/*\n * Prints:\n * <base href=\"/mypage/\" />\n */\n<base href=\"<?= $this->basePath() ?>\" />\n\n/*\n * Prints:\n * <link rel=\"stylesheet\" type=\"text/css\" href=\"/mypage/css/base.css\" />\n */\n<link rel=\"stylesheet\" type=\"text/css\"\n     href=\"<?= $this->basePath('css/base.css') ?>\" />\n\n\n\n\n\nindex.php script\n\n\nFor simplicity's sake, we strip out the entry PHP file (e.g., \nindex.php\n)\nfrom the base URL. However, in some situations this may cause a problem. If\none occurs, use \n$this->plugin('basePath')->setBasePath()\n to manually set the\nbase path.",
            "title": "BasePath"
        },
        {
            "location": "/helpers/base-path/#basepath",
            "text": "While most URLs generated by the framework have the base URL prepended\nautomatically, developers will need to prepend the base URL to their own URLs\n(usually inside an  href  attribute) in order for paths to resources to be\ncorrect.  If you're running a zend-mvc application,  basePath()  will point to the public  folder of the application's root.",
            "title": "BasePath"
        },
        {
            "location": "/helpers/base-path/#basic-usage",
            "text": "/*\n * The following assume that the base URL of the page/application is \"/mypage\".\n */\n\n/*\n * Prints:\n * <base href=\"/mypage/\" />\n */\n<base href=\"<?= $this->basePath() ?>\" />\n\n/*\n * Prints:\n * <link rel=\"stylesheet\" type=\"text/css\" href=\"/mypage/css/base.css\" />\n */\n<link rel=\"stylesheet\" type=\"text/css\"\n     href=\"<?= $this->basePath('css/base.css') ?>\" />",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/base-path/#indexphp-script",
            "text": "For simplicity's sake, we strip out the entry PHP file (e.g.,  index.php )\nfrom the base URL. However, in some situations this may cause a problem. If\none occurs, use  $this->plugin('basePath')->setBasePath()  to manually set the\nbase path.",
            "title": "index.php script"
        },
        {
            "location": "/helpers/cycle/",
            "text": "Cycle\n\n\nThe \nCycle\n helper is used to alternate a set of values.\n\n\nBasic Usage\n\n\nTo add elements to cycle, specify them in constructor:\n\n\n<table>\n    <?php foreach ($this->books as $book): ?>\n        <tr class=\"<?= $this->cycle(['odd', 'even'])->next() ?>\">\n            <td><?= $this->escapeHtml($book['author']) ?></td>\n        </tr>\n    <?php endforeach ?>\n</table>\n\n\n\nThe output:\n\n\n<table>\n    <tr class=\"odd\">\n       <td>First</td>\n    </tr>\n    <tr class=\"even\">\n       <td>Second</td>\n    </tr>\n</table>\n\n\n\nInstead of passing the data at invocation, you can assign it ahead of time:\n\n\n<?php $this->cycle()->assign(['odd', 'even']); ?>\n\n\n\nYou can also cycle in reverse, using the \nprev()\n method instead of \nnext()\n:\n\n\n<table>\n    <?php foreach ($this->books as $book): ?>\n    <tr class=\"<?= $this->cycle()->prev() ?>\">\n       <td><?php echo $this->escapeHtml($book['author']) ?></td>\n    </tr>\n    <?php endforeach ?>\n</table>\n\n\n\nThe output of the two previous examples combined becomes:\n\n\n<table>\n    <tr class=\"even\">\n       <td>First</td>\n    </tr>\n    <tr class=\"odd\">\n       <td>Second</td>\n    </tr>\n</table>\n\n\n\nWorking with two or more cycles\n\n\nIf you are nesting cycles, you must provide all but one of them with a name; do\nthis by providing a second parameter to the \ncycle()\n invocation:\n\n$this->cycle(array('odd', 'even'), 'cycle2')\n\n\n<table>\n    <?php foreach ($this->books as $book): ?>\n        <tr class=\"<?= $this->cycle(['odd', 'even'])->next() ?>\">\n            <td><?= $this->cycle([1, 2, 3], 'number')->next() ?></td>\n            <td><?= $this->escapeHtml($book['author']) ?></td>\n        </tr>\n    <?php endforeach ?>\n</table>\n\n\n\nYou can also provide a \n$name\n argument to \nassign()\n:\n\n\n<?php $this->cycle()->assign([1, 2, 3], 'number'); ?>\n\n\n\nOr use the \nsetName()\n method priort to invoking either of \nnext()\n or \nprev()\n.\n\n\nAs a combined example:\n\n\n<?php\n$this->cycle()->assign(['odd', 'even'], 'classes');\n$this->cycle()->assign([1, 2, 3], 'numbers');\n?>\n<table>\n    <?php foreach ($this->books as $book): ?>\n        <tr class=\"<?= $this->cycle()->setName('classes')->next() ?>\">\n            <td><?= $this->cycle()->setName('numbers')->next() ?></td>\n            <td><?= $this->escapeHtml($book['author']) ?></td>\n        </tr>\n    <?php endforeach ?>\n</table>",
            "title": "Cycle"
        },
        {
            "location": "/helpers/cycle/#cycle",
            "text": "The  Cycle  helper is used to alternate a set of values.",
            "title": "Cycle"
        },
        {
            "location": "/helpers/cycle/#basic-usage",
            "text": "To add elements to cycle, specify them in constructor:  <table>\n    <?php foreach ($this->books as $book): ?>\n        <tr class=\"<?= $this->cycle(['odd', 'even'])->next() ?>\">\n            <td><?= $this->escapeHtml($book['author']) ?></td>\n        </tr>\n    <?php endforeach ?>\n</table>  The output:  <table>\n    <tr class=\"odd\">\n       <td>First</td>\n    </tr>\n    <tr class=\"even\">\n       <td>Second</td>\n    </tr>\n</table>  Instead of passing the data at invocation, you can assign it ahead of time:  <?php $this->cycle()->assign(['odd', 'even']); ?>  You can also cycle in reverse, using the  prev()  method instead of  next() :  <table>\n    <?php foreach ($this->books as $book): ?>\n    <tr class=\"<?= $this->cycle()->prev() ?>\">\n       <td><?php echo $this->escapeHtml($book['author']) ?></td>\n    </tr>\n    <?php endforeach ?>\n</table>  The output of the two previous examples combined becomes:  <table>\n    <tr class=\"even\">\n       <td>First</td>\n    </tr>\n    <tr class=\"odd\">\n       <td>Second</td>\n    </tr>\n</table>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/cycle/#working-with-two-or-more-cycles",
            "text": "If you are nesting cycles, you must provide all but one of them with a name; do\nthis by providing a second parameter to the  cycle()  invocation: $this->cycle(array('odd', 'even'), 'cycle2')  <table>\n    <?php foreach ($this->books as $book): ?>\n        <tr class=\"<?= $this->cycle(['odd', 'even'])->next() ?>\">\n            <td><?= $this->cycle([1, 2, 3], 'number')->next() ?></td>\n            <td><?= $this->escapeHtml($book['author']) ?></td>\n        </tr>\n    <?php endforeach ?>\n</table>  You can also provide a  $name  argument to  assign() :  <?php $this->cycle()->assign([1, 2, 3], 'number'); ?>  Or use the  setName()  method priort to invoking either of  next()  or  prev() .  As a combined example:  <?php\n$this->cycle()->assign(['odd', 'even'], 'classes');\n$this->cycle()->assign([1, 2, 3], 'numbers');\n?>\n<table>\n    <?php foreach ($this->books as $book): ?>\n        <tr class=\"<?= $this->cycle()->setName('classes')->next() ?>\">\n            <td><?= $this->cycle()->setName('numbers')->next() ?></td>\n            <td><?= $this->escapeHtml($book['author']) ?></td>\n        </tr>\n    <?php endforeach ?>\n</table>",
            "title": "Working with two or more cycles"
        },
        {
            "location": "/helpers/doctype/",
            "text": "Doctype\n\n\nValid HTML and XHTML documents should include a \nDOCTYPE\n declaration. Besides being difficult\nto remember, these can also affect how certain elements in your document should be rendered (for\ninstance, \nCDATA\n escaping in \n<script>\n and \n<style>\n elements.\n\n\nThe \nDoctype\n helper allows you to specify one of the following types:\n\n\n\n\nXHTML11\n\n\nXHTML1_STRICT\n\n\nXHTML1_TRANSITIONAL\n\n\nXHTML1_FRAMESET\n\n\nXHTML1_RDFA\n\n\nXHTML1_RDFA11\n\n\nXHTML_BASIC1\n\n\nXHTML5\n\n\nHTML4_STRICT\n\n\nHTML4_LOOSE\n\n\nHTML4_FRAMESET\n\n\nHTML5\n\n\nCUSTOM_XHTML\n\n\nCUSTOM\n\n\n\n\nYou can also specify a custom doctype as long as it is well-formed.\n\n\nThe \nDoctype\n helper is a concrete implementation of the\n\nPlaceholder helper\n.\n\n\nBasic Usage\n\n\nYou may specify the doctype at any time. However, helpers that depend on the\ndoctype for their output will recognize it only after you have set it, so the\neasiest approach is to specify it in your bootstrap:\n\n\nuse Zend\\View\\Helper\\Doctype;\n\n$doctypeHelper = new Doctype();\n$doctypeHelper->doctype('XHTML1_STRICT');\n\n\n\nAnd then print it out on top of your layout script:\n\n\n<?php echo $this->doctype() ?>\n\n\n\nWithin an application based off the \nskeleton application\n,\nyou can specify the doctype via configuration:\n\n\n// module/Application/config/module.config.php:\nreturn [\n    /* ... */\n    'view_manager' => [\n        'doctype' => 'html5',\n        /* ... */\n    ],\n];\n\n\n\nRetrieving the Doctype\n\n\nIf you need to know the doctype, you can do so by calling \ngetDoctype()\n on the\nhelper, which is returned by invoking the helper from the view.\n\n\n$doctype = $this->doctype()->getDoctype();\n\n\n\nTypically, you'll want to know if the doctype is XHTML or not; for this, the\n\nisXhtml()\n method will suffice:\n\n\nif ($this->doctype()->isXhtml()) {\n    // do something differently\n}\n\n\n\nYou can also check if the doctype represents an HTML5 document.\n\n\nif ($this->doctype()->isHtml5()) {\n    // do something differently\n}\n\n\n\nChoosing a Doctype to Use with the Open Graph Protocol\n\n\nTo implement the \nOpen Graph Protocol\n, you may\nspecify the \nXHTML1_RDFA\n doctype. This doctype allows a developer to use the\n\nResource Description Framework\n within\nan XHTML document.\n\n\nuse Zend\\View\\Helper\\Doctype;\n\n$doctypeHelper = new Doctype();\n$doctypeHelper->doctype('XHTML1_RDFA');\n\n\n\nThe RDFa doctype allows XHTML to validate when the 'property' meta tag attribute\nis used per the Open Graph Protocol spec. Example within a view script:\n\n\n<?= $this->doctype('XHTML1_RDFA'); ?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:og=\"http://opengraphprotocol.org/schema/\">\n<head>\n   <meta property=\"og:type\" content=\"musician\" />\n\n\n\nIn the previous example, we set the property to \nog:type\n. The \nog\n references\nthe Open Graph namespace we specified in the html tag. The content identifies\nthe page as being about a musician. See the \nOpen Graph Protocol\ndocumentation\n for supported properties. The\n\nHeadMeta helper\n may be used to programmatically set these Open\nGraph Protocol meta tags.\n\n\nHere is how you check if the doctype is set to \nXHTML1_RDFA\n:\n\n\n<?= $this->doctype() ?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\"\n    <?php if ($view->doctype()->isRdfa()): ?>\n      xmlns:og=\"http://opengraphprotocol.org/schema/\"\n      xmlns:fb=\"http://www.facebook.com/2008/fbml\"\n    <?php endif; ?>\n>\n\n\n\nZend MVC View Manager\n\n\nIf you're running a ZendMvc application, you should specify doctype via the\n\nViewManager\n service.",
            "title": "Doctype"
        },
        {
            "location": "/helpers/doctype/#doctype",
            "text": "Valid HTML and XHTML documents should include a  DOCTYPE  declaration. Besides being difficult\nto remember, these can also affect how certain elements in your document should be rendered (for\ninstance,  CDATA  escaping in  <script>  and  <style>  elements.  The  Doctype  helper allows you to specify one of the following types:   XHTML11  XHTML1_STRICT  XHTML1_TRANSITIONAL  XHTML1_FRAMESET  XHTML1_RDFA  XHTML1_RDFA11  XHTML_BASIC1  XHTML5  HTML4_STRICT  HTML4_LOOSE  HTML4_FRAMESET  HTML5  CUSTOM_XHTML  CUSTOM   You can also specify a custom doctype as long as it is well-formed.  The  Doctype  helper is a concrete implementation of the Placeholder helper .",
            "title": "Doctype"
        },
        {
            "location": "/helpers/doctype/#basic-usage",
            "text": "You may specify the doctype at any time. However, helpers that depend on the\ndoctype for their output will recognize it only after you have set it, so the\neasiest approach is to specify it in your bootstrap:  use Zend\\View\\Helper\\Doctype;\n\n$doctypeHelper = new Doctype();\n$doctypeHelper->doctype('XHTML1_STRICT');  And then print it out on top of your layout script:  <?php echo $this->doctype() ?>  Within an application based off the  skeleton application ,\nyou can specify the doctype via configuration:  // module/Application/config/module.config.php:\nreturn [\n    /* ... */\n    'view_manager' => [\n        'doctype' => 'html5',\n        /* ... */\n    ],\n];",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/doctype/#retrieving-the-doctype",
            "text": "If you need to know the doctype, you can do so by calling  getDoctype()  on the\nhelper, which is returned by invoking the helper from the view.  $doctype = $this->doctype()->getDoctype();  Typically, you'll want to know if the doctype is XHTML or not; for this, the isXhtml()  method will suffice:  if ($this->doctype()->isXhtml()) {\n    // do something differently\n}  You can also check if the doctype represents an HTML5 document.  if ($this->doctype()->isHtml5()) {\n    // do something differently\n}",
            "title": "Retrieving the Doctype"
        },
        {
            "location": "/helpers/doctype/#choosing-a-doctype-to-use-with-the-open-graph-protocol",
            "text": "To implement the  Open Graph Protocol , you may\nspecify the  XHTML1_RDFA  doctype. This doctype allows a developer to use the Resource Description Framework  within\nan XHTML document.  use Zend\\View\\Helper\\Doctype;\n\n$doctypeHelper = new Doctype();\n$doctypeHelper->doctype('XHTML1_RDFA');  The RDFa doctype allows XHTML to validate when the 'property' meta tag attribute\nis used per the Open Graph Protocol spec. Example within a view script:  <?= $this->doctype('XHTML1_RDFA'); ?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:og=\"http://opengraphprotocol.org/schema/\">\n<head>\n   <meta property=\"og:type\" content=\"musician\" />  In the previous example, we set the property to  og:type . The  og  references\nthe Open Graph namespace we specified in the html tag. The content identifies\nthe page as being about a musician. See the  Open Graph Protocol\ndocumentation  for supported properties. The HeadMeta helper  may be used to programmatically set these Open\nGraph Protocol meta tags.  Here is how you check if the doctype is set to  XHTML1_RDFA :  <?= $this->doctype() ?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\"\n    <?php if ($view->doctype()->isRdfa()): ?>\n      xmlns:og=\"http://opengraphprotocol.org/schema/\"\n      xmlns:fb=\"http://www.facebook.com/2008/fbml\"\n    <?php endif; ?>\n>",
            "title": "Choosing a Doctype to Use with the Open Graph Protocol"
        },
        {
            "location": "/helpers/doctype/#zend-mvc-view-manager",
            "text": "If you're running a ZendMvc application, you should specify doctype via the ViewManager  service.",
            "title": "Zend MVC View Manager"
        },
        {
            "location": "/helpers/flash-messenger/",
            "text": "FlashMessenger\n\n\nThe \nFlashMessenger\n helper is used to render the messages of the\n\nFlashMessenger MVC plugin\n.\n\n\nBasic Usage\n\n\nWhen only using the default \nnamespace\n for the \nFlashMessenger\n, you can do the\nfollowing:\n\n\n// Usable in any of your .phtml files\necho $this->flashMessenger()->render();\n\n\n\nThe first argument of the \nrender()\n function is the \nnamespace\n. If no\n\nnamespace\n is defined, the default\n\nZend\\Mvc\\Controller\\Plugin\\FlashMessenger::NAMESPACE_DEFAULT\n will be used,\nwhich translates to \ndefault\n.\n\n\n// Usable in any of your .phtml files\necho $this->flashMessenger()->render('error');\n\n// Alternatively use one of the pre-defined namespaces \n// (aka: use Zend\\Mvc\\Controller\\Plugin\\FlashMessenger;)\necho $this->flashMessenger()->render(FlashMessenger::NAMESPACE_SUCCESS);\n\n\n\nCSS Layout\n\n\nThe \nFlashMessenger\n default rendering adds a CSS class to the generated HTML,\nthat matches the defined \nnamespace\n that should be rendered. While it may work\nwell for the default cases, every so often you may want to add specific CSS\nclasses to the HTML output. This can be done while making use of the second\nparameter of the \nrender()\n function.\n\n\n// Usable in any of your .phtml files\necho $this->flashMessenger()->render('error', ['alert', 'alert-danger']);\n\n\n\nThe output of this example, using the default HTML rendering settings, would\nlook like this:\n\n\n<ul class=\"alert alert-danger\">\n    <li>Some FlashMessenger Content</li>\n    <li>You, the developer, are AWESOME!</li>\n</ul>\n\n\n\nHTML Layout\n\n\nAside from modifying the rendered CSS classes of the \nFlashMessenger\n, you are\nfurthermore able to modify the generated HTML as a whole to create even more\ndistinct visuals for your flash messages. The default output format is defined\nwithin the source code of the \nFlashMessenger\n view helper itself.\n\n\n// Zend/View/Helper/FlashMessenger.php#L41-L43\nprotected $messageCloseString     = '</li></ul>';\nprotected $messageOpenFormat      = '<ul%s><li>';\nprotected $messageSeparatorString = '</li><li>';\n\n\n\nThese defaults exactly match what we're trying to do. The placeholder \n%s\n will\nbe filled with the CSS classes output.\n\n\nTo change this, all we need to do is call the respective setter methods of these\nvariables and give them new strings; for example:\n\n\n// In any of your .phtml files:\necho $this->flashMessenger()\n    ->setMessageOpenFormat('<div%s><p>')\n    ->setMessageSeparatorString('</p><p>')\n    ->setMessageCloseString('</p></div>')\n    ->render('success');\n\n\n\nThe above code sample then would then generate the following output:\n\n\n<div class=\"success\">\n    <p>Some FlashMessenger Content</p>\n    <p>You, who's reading the docs, are AWESOME!</p>\n</div>\n\n\n\nSample Modification for Twitter Bootstrap 3\n\n\nTaking all the above knowledge into account, we can create a nice, highly usable\nand user-friendly rendering strategy using the\n\nBootstrap front-end framework\n version 3 layouts:\n\n\n// In any of your .phtml files:\n$flash = $this->flashMessenger();\n$flash->setMessageOpenFormat('<div%s>\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">\n        &times;\n    </button>\n    <ul><li>')\n    ->setMessageSeparatorString('</li><li>')\n    ->setMessageCloseString('</li></ul></div>');\n\necho $flash->render('error',   array('alert', 'alert-dismissible', 'alert-danger'));\necho $flash->render('info',    array('alert', 'alert-dismissible', 'alert-info'));\necho $flash->render('default', array('alert', 'alert-dismissible', 'alert-warning'));\necho $flash->render('success', array('alert', 'alert-dismissible', 'alert-success'));\n\n\n\nThe output of the above example would create dismissable \nFlashMessages\n with\nthe following HTML markup. The example only covers one type of \nFlashMessenger\n\noutput; if you would have several \nFlashMessages\n available in each of the\nrendered \nnamespaces\n, then you would receive the same output multiple times\nonly having different CSS classes applied.\n\n\n<div class=\"alert alert-dismissable alert-success\">\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">\u00d7</button>\n    <ul>\n        <li>Some FlashMessenger Content</li>\n        <li>You, who's reading the docs, are AWESOME!</li>\n    </ul>\n</div>\n\n\n\nAlternative Configuration of the ViewHelper Layout\n\n\nZend\\View\\Helper\\Service\\FlashMessengerFactory\n checks the application\nconfiguration, making it possible to set up the \nFlashMessenger\n strings through\nyour \nmodule.config.php\n, too. The next example will set up the output to be\nidentical with the above Twitter Bootstrap 3 Example\n\n\n'view_helper_config' => [\n    'flashmessenger' => [\n        'message_open_format'      => '<div%s><button type=\"button\" class=\"close\"\ndata-dismiss=\"alert\" aria-hidden=\"true\">&times;</button><ul><li>',\n        'message_close_string'     => '</li></ul></div>',\n        'message_separator_string' => '</li><li>',\n    ],\n],",
            "title": "FlashMessenger"
        },
        {
            "location": "/helpers/flash-messenger/#flashmessenger",
            "text": "The  FlashMessenger  helper is used to render the messages of the FlashMessenger MVC plugin .",
            "title": "FlashMessenger"
        },
        {
            "location": "/helpers/flash-messenger/#basic-usage",
            "text": "When only using the default  namespace  for the  FlashMessenger , you can do the\nfollowing:  // Usable in any of your .phtml files\necho $this->flashMessenger()->render();  The first argument of the  render()  function is the  namespace . If no namespace  is defined, the default Zend\\Mvc\\Controller\\Plugin\\FlashMessenger::NAMESPACE_DEFAULT  will be used,\nwhich translates to  default .  // Usable in any of your .phtml files\necho $this->flashMessenger()->render('error');\n\n// Alternatively use one of the pre-defined namespaces \n// (aka: use Zend\\Mvc\\Controller\\Plugin\\FlashMessenger;)\necho $this->flashMessenger()->render(FlashMessenger::NAMESPACE_SUCCESS);",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/flash-messenger/#css-layout",
            "text": "The  FlashMessenger  default rendering adds a CSS class to the generated HTML,\nthat matches the defined  namespace  that should be rendered. While it may work\nwell for the default cases, every so often you may want to add specific CSS\nclasses to the HTML output. This can be done while making use of the second\nparameter of the  render()  function.  // Usable in any of your .phtml files\necho $this->flashMessenger()->render('error', ['alert', 'alert-danger']);  The output of this example, using the default HTML rendering settings, would\nlook like this:  <ul class=\"alert alert-danger\">\n    <li>Some FlashMessenger Content</li>\n    <li>You, the developer, are AWESOME!</li>\n</ul>",
            "title": "CSS Layout"
        },
        {
            "location": "/helpers/flash-messenger/#html-layout",
            "text": "Aside from modifying the rendered CSS classes of the  FlashMessenger , you are\nfurthermore able to modify the generated HTML as a whole to create even more\ndistinct visuals for your flash messages. The default output format is defined\nwithin the source code of the  FlashMessenger  view helper itself.  // Zend/View/Helper/FlashMessenger.php#L41-L43\nprotected $messageCloseString     = '</li></ul>';\nprotected $messageOpenFormat      = '<ul%s><li>';\nprotected $messageSeparatorString = '</li><li>';  These defaults exactly match what we're trying to do. The placeholder  %s  will\nbe filled with the CSS classes output.  To change this, all we need to do is call the respective setter methods of these\nvariables and give them new strings; for example:  // In any of your .phtml files:\necho $this->flashMessenger()\n    ->setMessageOpenFormat('<div%s><p>')\n    ->setMessageSeparatorString('</p><p>')\n    ->setMessageCloseString('</p></div>')\n    ->render('success');  The above code sample then would then generate the following output:  <div class=\"success\">\n    <p>Some FlashMessenger Content</p>\n    <p>You, who's reading the docs, are AWESOME!</p>\n</div>",
            "title": "HTML Layout"
        },
        {
            "location": "/helpers/flash-messenger/#sample-modification-for-twitter-bootstrap-3",
            "text": "Taking all the above knowledge into account, we can create a nice, highly usable\nand user-friendly rendering strategy using the Bootstrap front-end framework  version 3 layouts:  // In any of your .phtml files:\n$flash = $this->flashMessenger();\n$flash->setMessageOpenFormat('<div%s>\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">\n        &times;\n    </button>\n    <ul><li>')\n    ->setMessageSeparatorString('</li><li>')\n    ->setMessageCloseString('</li></ul></div>');\n\necho $flash->render('error',   array('alert', 'alert-dismissible', 'alert-danger'));\necho $flash->render('info',    array('alert', 'alert-dismissible', 'alert-info'));\necho $flash->render('default', array('alert', 'alert-dismissible', 'alert-warning'));\necho $flash->render('success', array('alert', 'alert-dismissible', 'alert-success'));  The output of the above example would create dismissable  FlashMessages  with\nthe following HTML markup. The example only covers one type of  FlashMessenger \noutput; if you would have several  FlashMessages  available in each of the\nrendered  namespaces , then you would receive the same output multiple times\nonly having different CSS classes applied.  <div class=\"alert alert-dismissable alert-success\">\n    <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">\u00d7</button>\n    <ul>\n        <li>Some FlashMessenger Content</li>\n        <li>You, who's reading the docs, are AWESOME!</li>\n    </ul>\n</div>",
            "title": "Sample Modification for Twitter Bootstrap 3"
        },
        {
            "location": "/helpers/flash-messenger/#alternative-configuration-of-the-viewhelper-layout",
            "text": "Zend\\View\\Helper\\Service\\FlashMessengerFactory  checks the application\nconfiguration, making it possible to set up the  FlashMessenger  strings through\nyour  module.config.php , too. The next example will set up the output to be\nidentical with the above Twitter Bootstrap 3 Example  'view_helper_config' => [\n    'flashmessenger' => [\n        'message_open_format'      => '<div%s><button type=\"button\" class=\"close\"\ndata-dismiss=\"alert\" aria-hidden=\"true\">&times;</button><ul><li>',\n        'message_close_string'     => '</li></ul></div>',\n        'message_separator_string' => '</li><li>',\n    ],\n],",
            "title": "Alternative Configuration of the ViewHelper Layout"
        },
        {
            "location": "/helpers/gravatar/",
            "text": "Gravatar Helper\n\n\nThe \nGravatar\n helper is useful for rendering image HTML markup returned from\nthe \ngravatar.com\n service.\n\n\nBasic Usage\n\n\nYou can use the \nGravatar\n helper anywhere in view scripts per the following example:\n\n\necho $this->gravatar('email@example.com')->getImgTag();\n\n\n\nThe first (and only, in this example) argument passed to the \nGravatar\n helper\nis an e-mail for which you want grab an avatar from gravatar.com. For\nconvenience, this e-mail will be automatically hashed via the md5 algorithm.\n\n\nThis will render the HTML below:\n\n\n<img src=\"http://www.gravatar.com/avatar/5658ffccee7f0ebfda2b226238b1eb6e?s=80&d=mm&r=g\">\n\n\n\nThe helper already provides URL defaults for you.\n\n\nCustom Settings\n\n\nYou can customize the request for a gravatar.com image by using setter methods\non the view helper:\n\n\n$gravatar = $this->gravatar();\n\n// Set the email instead of passing it via helper invocation\n$gravatar->setEmail('email@example.com');\n\n// Set the image size you want gravatar.com to return, in pixels\n$gravatar->setImgSize(40);\n\n// Set the default avatar image to use if gravatar.com does not find a match\n$gravatar->setDefaultImg( \\Zend\\View\\Helper\\Gravatar::DEFAULT_MM );\n\n// Set the avatar \"rating\" threshold (often used to omit NSFW avatars)\n$gravatar->setRating( \\Zend\\View\\Helper\\Gravatar::RATING_G );\n\n// Indicate that a secure URI should be used for the image source\n$gravatar->setSecure(true);\n\n// Render the <img> tag with the email you've set previously\necho $gravatar->getImgTag();\n\n\n\nAlternately, you can pass an array as the second argument on invocation, with\nthe following keys:\n\n\n$settings = [\n    'img_size'    => 40,\n    'default_img' => \\Zend\\View\\Helper\\Gravatar::DEFAULT_MM,\n    'rating'      => \\Zend\\View\\Helper\\Gravatar::RATING_G,\n    'secure'      => null,\n];\n$email = 'email@example.com';\necho $this->gravatar($email, $settings);\n\n\n\n\n\nScheme autodiscovery\n\n\nPassing \nnull\n for the \nsecure\n setting will cause the view helper to choose a\nschema that matches the current request to your application. This is the\ndefault behavior.\n\n\n\n\nAs you can see in the above examples, there are predefined settings for the\ndefault image and rating.\n\n\nThe Gravatar helper defines the following constants for ratings:\n\n\n\n\nRATING_G\n\n\nRATING_PG\n\n\nRATING_R\n\n\nRATING_X\n\n\n\n\nThe helper defines the following constants for the default image: \n\n\n\n\nDEFAULT_404\n\n\nDEFAULT_MM\n\n\nDEFAULT_IDENTICON\n\n\nDEFAULT_MONSTERID\n\n\nDEFAULT_WAVATAR\n\n\n\n\nYou may also provide custom attributes for the generated \nimg\n tag. To do this,\npass an attributes array to the \nsetAttributes()\n method:\n\n\n$gravatar = $this->gravatar('email@example.com');\n\n// Suppose that I want to add the class attribute with a value of\n// \"gravatarcls\" to the rendered <img> tag:\n$attr = [\n    'class' => 'gravatarcls',\n];\necho $gravatar->setAttributes($attr)->getImgTag(); \n\n\n\nAlternately, you can pass this array as the third argument during helper\ninvocation:\n\n\n$email = 'email@example.com';\n$settings = [\n    'default_img' => \\Zend\\View\\Helper\\Gravatar::DEFAULT_MM,\n];\n$attr = [\n    'class' => 'gravatar-image',\n    'id'    => 'gravatar',\n];\n\necho $this->gravatar($email, $settings, $attr);",
            "title": "Gravatar"
        },
        {
            "location": "/helpers/gravatar/#gravatar-helper",
            "text": "The  Gravatar  helper is useful for rendering image HTML markup returned from\nthe  gravatar.com  service.",
            "title": "Gravatar Helper"
        },
        {
            "location": "/helpers/gravatar/#basic-usage",
            "text": "You can use the  Gravatar  helper anywhere in view scripts per the following example:  echo $this->gravatar('email@example.com')->getImgTag();  The first (and only, in this example) argument passed to the  Gravatar  helper\nis an e-mail for which you want grab an avatar from gravatar.com. For\nconvenience, this e-mail will be automatically hashed via the md5 algorithm.  This will render the HTML below:  <img src=\"http://www.gravatar.com/avatar/5658ffccee7f0ebfda2b226238b1eb6e?s=80&d=mm&r=g\">  The helper already provides URL defaults for you.",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/gravatar/#custom-settings",
            "text": "You can customize the request for a gravatar.com image by using setter methods\non the view helper:  $gravatar = $this->gravatar();\n\n// Set the email instead of passing it via helper invocation\n$gravatar->setEmail('email@example.com');\n\n// Set the image size you want gravatar.com to return, in pixels\n$gravatar->setImgSize(40);\n\n// Set the default avatar image to use if gravatar.com does not find a match\n$gravatar->setDefaultImg( \\Zend\\View\\Helper\\Gravatar::DEFAULT_MM );\n\n// Set the avatar \"rating\" threshold (often used to omit NSFW avatars)\n$gravatar->setRating( \\Zend\\View\\Helper\\Gravatar::RATING_G );\n\n// Indicate that a secure URI should be used for the image source\n$gravatar->setSecure(true);\n\n// Render the <img> tag with the email you've set previously\necho $gravatar->getImgTag();  Alternately, you can pass an array as the second argument on invocation, with\nthe following keys:  $settings = [\n    'img_size'    => 40,\n    'default_img' => \\Zend\\View\\Helper\\Gravatar::DEFAULT_MM,\n    'rating'      => \\Zend\\View\\Helper\\Gravatar::RATING_G,\n    'secure'      => null,\n];\n$email = 'email@example.com';\necho $this->gravatar($email, $settings);",
            "title": "Custom Settings"
        },
        {
            "location": "/helpers/gravatar/#scheme-autodiscovery",
            "text": "Passing  null  for the  secure  setting will cause the view helper to choose a\nschema that matches the current request to your application. This is the\ndefault behavior.   As you can see in the above examples, there are predefined settings for the\ndefault image and rating.  The Gravatar helper defines the following constants for ratings:   RATING_G  RATING_PG  RATING_R  RATING_X   The helper defines the following constants for the default image:    DEFAULT_404  DEFAULT_MM  DEFAULT_IDENTICON  DEFAULT_MONSTERID  DEFAULT_WAVATAR   You may also provide custom attributes for the generated  img  tag. To do this,\npass an attributes array to the  setAttributes()  method:  $gravatar = $this->gravatar('email@example.com');\n\n// Suppose that I want to add the class attribute with a value of\n// \"gravatarcls\" to the rendered <img> tag:\n$attr = [\n    'class' => 'gravatarcls',\n];\necho $gravatar->setAttributes($attr)->getImgTag();   Alternately, you can pass this array as the third argument during helper\ninvocation:  $email = 'email@example.com';\n$settings = [\n    'default_img' => \\Zend\\View\\Helper\\Gravatar::DEFAULT_MM,\n];\n$attr = [\n    'class' => 'gravatar-image',\n    'id'    => 'gravatar',\n];\n\necho $this->gravatar($email, $settings, $attr);",
            "title": "Scheme autodiscovery"
        },
        {
            "location": "/helpers/head-link/",
            "text": "HeadLink\n\n\nThe HTML \n<link>\n element is increasingly used for linking a variety of\nresources for your site: stylesheets, feeds, favicons, trackbacks, and more. The\n\nHeadLink\n helper provides a simple interface for creating and aggregating these\nelements for later retrieval and output in your layout script.\n\n\nThe \nHeadLink\n helper has special methods for adding stylesheet links to its\nstack:\n\n\n\n\nappendStylesheet($href, $media = 'screen', $conditionalStylesheet = '', $extras = [])\n\n\noffsetSetStylesheet($index, $href, $media = 'screen', $conditionalStylesheet = '', $extras = [])\n\n\nprependStylesheet($href, $media = 'screen', $conditionalStylesheet = '', $extras = [])\n\n\nsetStylesheet($href, $media = 'screen', $conditionalStylesheet = '', $extras = [])\n\n\n\n\nThe \n$media\n value defaults to 'screen', but may be any valid media value.\n\n$conditionalStylesheet\n is a string or boolean \nfalse\n, and will be used at\nrendering time to determine if special comments should be included to prevent\nloading of the stylesheet on certain platforms. \n$extras\n is an array of any\nextra values that you want to be added to the tag.\n\n\nAdditionally, the \nHeadLink\n helper has special methods for adding 'alternate'\nlinks to its stack:\n\n\n\n\nappendAlternate($href, $type, $title, $extras = [])\n\n\noffsetSetAlternate($index, $href, $type, $title, $extras = [])\n\n\nprependAlternate($href, $type, $title, $extras = [])\n\n\nsetAlternate($href, $type, $title, $extras = [])\n\n\n\n\nThe \nheadLink()\n helper method allows specifying all attributes necessary for a\n\n<link>\n element, and allows you to also specify placement: whether the\nnew element replaces all others, prepends (top of stack), or appends (end of\nstack).\n\n\nThe \nHeadLink\n helper is a concrete implementation of the\n\nPlaceholder helper\n.\n\n\nBasic Usage\n\n\nYou may specify a \nheadLink\n at any time. Typically, you will specify global\nlinks in your layout script, and application specific links in your application\nview scripts. In your layout script, in the \n<head>\n section, you will then echo\nthe helper to output it.\n\n\n<?php\n// setting links in a view script:\n$this->headLink(['rel' => 'icon', 'href' => '/img/favicon.ico'], 'PREPEND')\n     ->appendStylesheet('/styles/basic.css')\n     ->prependStylesheet(\n         '/styles/moz.css',\n         'screen',\n         true,\n         ['id' => 'my_stylesheet']\n     );\n\n// rendering the links from the layout:\necho $this->headLink();\n?>\n\n\n\nOutput:\n\n\n<link href=\"/styles/moz.css\" media=\"screen\" rel=\"stylesheet\" type=\"text/css\" id=\"my_stylesheet\">\n<link href=\"/img/favicon.ico\" rel=\"icon\">\n<link href=\"/styles/basic.css\" media=\"screen\" rel=\"stylesheet\" type=\"text/css\">",
            "title": "HeadLink"
        },
        {
            "location": "/helpers/head-link/#headlink",
            "text": "The HTML  <link>  element is increasingly used for linking a variety of\nresources for your site: stylesheets, feeds, favicons, trackbacks, and more. The HeadLink  helper provides a simple interface for creating and aggregating these\nelements for later retrieval and output in your layout script.  The  HeadLink  helper has special methods for adding stylesheet links to its\nstack:   appendStylesheet($href, $media = 'screen', $conditionalStylesheet = '', $extras = [])  offsetSetStylesheet($index, $href, $media = 'screen', $conditionalStylesheet = '', $extras = [])  prependStylesheet($href, $media = 'screen', $conditionalStylesheet = '', $extras = [])  setStylesheet($href, $media = 'screen', $conditionalStylesheet = '', $extras = [])   The  $media  value defaults to 'screen', but may be any valid media value. $conditionalStylesheet  is a string or boolean  false , and will be used at\nrendering time to determine if special comments should be included to prevent\nloading of the stylesheet on certain platforms.  $extras  is an array of any\nextra values that you want to be added to the tag.  Additionally, the  HeadLink  helper has special methods for adding 'alternate'\nlinks to its stack:   appendAlternate($href, $type, $title, $extras = [])  offsetSetAlternate($index, $href, $type, $title, $extras = [])  prependAlternate($href, $type, $title, $extras = [])  setAlternate($href, $type, $title, $extras = [])   The  headLink()  helper method allows specifying all attributes necessary for a <link>  element, and allows you to also specify placement: whether the\nnew element replaces all others, prepends (top of stack), or appends (end of\nstack).  The  HeadLink  helper is a concrete implementation of the Placeholder helper .",
            "title": "HeadLink"
        },
        {
            "location": "/helpers/head-link/#basic-usage",
            "text": "You may specify a  headLink  at any time. Typically, you will specify global\nlinks in your layout script, and application specific links in your application\nview scripts. In your layout script, in the  <head>  section, you will then echo\nthe helper to output it.  <?php\n// setting links in a view script:\n$this->headLink(['rel' => 'icon', 'href' => '/img/favicon.ico'], 'PREPEND')\n     ->appendStylesheet('/styles/basic.css')\n     ->prependStylesheet(\n         '/styles/moz.css',\n         'screen',\n         true,\n         ['id' => 'my_stylesheet']\n     );\n\n// rendering the links from the layout:\necho $this->headLink();\n?>  Output:  <link href=\"/styles/moz.css\" media=\"screen\" rel=\"stylesheet\" type=\"text/css\" id=\"my_stylesheet\">\n<link href=\"/img/favicon.ico\" rel=\"icon\">\n<link href=\"/styles/basic.css\" media=\"screen\" rel=\"stylesheet\" type=\"text/css\">",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/head-meta/",
            "text": "HeadMeta\n\n\nThe HTML \n<meta>\n element is used to provide meta information about your HTML\ndocument, typically keywords, document character set, caching pragmas, etc. Meta\ntags may be either of the \nhttp-equiv\n or \nname\n types, must contain a \ncontent\n\nattribute, and can also have either of the \nlang\n or \nscheme\n modifier\nattributes.\n\n\nThe \nHeadMeta\n helper supports the following methods for setting and adding meta tags:\n\n\n\n\nappendName($keyValue, $content, $conditionalName)\n\n\noffsetSetName($index, $keyValue, $content, $conditionalName)\n\n\nprependName($keyValue, $content, $conditionalName)\n\n\nsetName($keyValue, $content, $modifiers)\n\n\nappendHttpEquiv($keyValue, $content, $conditionalHttpEquiv)\n\n\noffsetSetHttpEquiv($index, $keyValue, $content, $conditionalHttpEquiv)\n\n\nprependHttpEquiv($keyValue, $content, $conditionalHttpEquiv)\n\n\nsetHttpEquiv($keyValue, $content, $modifiers)\n\n\nsetCharset($charset)\n\n\n\n\nThe following methods are also supported with \nXHTML1_RDFA\n doctype set with the\n\nDoctype helper\n.\n\n\n\n\nappendProperty($property, $content, $modifiers)\n\n\noffsetSetProperty($index, $property, $content, $modifiers)\n\n\nprependProperty($property, $content, $modifiers)\n\n\nsetProperty($property, $content, $modifiers)\n\n\n\n\nFinally, starting in 2.11.2, you can call the following method to determine\nwhether or not to autoescape values used in meta tags:\n\n\n\n\nsetAutoEscape(bool $autoEscape = true)\n (enabled by default)\n\n\n\n\n\n\nAutoEscape\n\n\nDisable this flag at your own risk.\n The one documented case where it is\nnecessary to disable the flag is when setting the \nX-UA-Compatible\n\n\nhttp-equiv\n value to switch behavior for Internet Explorer, as escaped values\nwill not trigger correct representation.\n\n\n\n\nThe \n$keyValue\n item is used to define a value for the \nname\n or \nhttp-equiv\n\nkey; \n$content\n is the value for the 'content' key, and \n$modifiers\n is an\noptional associative array that can contain keys for \nlang\n and/or \nscheme\n.\n\n\nYou may also set meta tags using the \nheadMeta()\n helper method, which has the\nfollowing signature: \nheadMeta($content, $keyValue, $keyType = 'name',\n$modifiers = array(), $placement = 'APPEND')\n.  \n$keyValue\n is the content for\nthe key specified in \n$keyType\n, which should be either \nname\n or \nhttp-equiv\n.\n\n$keyType\n may also be specified as \nproperty\n if the doctype has been set to\n\nXHTML1_RDFA\n. \n$placement\n can be \nSET\n (overwrites all previously stored\nvalues), \nAPPEND\n (added to end of stack), or \nPREPEND\n (added to top of stack).\n\n\nHeadMeta\n overrides each of \nappend()\n, \noffsetSet()\n, \nprepend()\n, and \nset()\n\nto enforce usage of the special methods as listed above. Internally, it stores\neach item as a \nstdClass\n token, which it later serializes using the\n\nitemToString()\n method. This allows you to perform checks on the items in the\nstack, and optionally modify these items by simply modifying the object\nreturned.\n\n\nThe \nHeadMeta\n helper is a concrete implementation of the\n\nPlaceholder helper\n.\n\n\nBasic Usage\n\n\nYou may specify a new meta tag at any time. Typically, you will specify\nclient-side caching rules or SEO keywords.\n\n\nFor instance, if you wish to specify SEO keywords, you'd be creating a meta name\ntag with the name \nkeywords\n and the content the keywords you wish to associate\nwith your page:\n\n\n// setting meta keywords\n$this->headMeta()->appendName('keywords', 'framework, PHP, productivity');\n\n\n\nIf you wished to set some client-side caching rules, you'd set \nhttp-equiv\n tags\nwith the rules you wish to enforce:\n\n\n// disabling client-side cache\n$this->headMeta()\n    ->appendHttpEquiv('expires', 'Wed, 26 Feb 1997 08:21:57 GMT')\n    ->appendHttpEquiv('pragma', 'no-cache')\n    ->appendHttpEquiv('Cache-Control', 'no-cache');\n\n\n\nAnother popular use for meta tags is setting the content type, character set,\nand language:\n\n\n// setting content type and character set\n$this->headMeta()\n    ->appendHttpEquiv('Content-Type', 'text/html; charset=UTF-8')\n    ->appendHttpEquiv('Content-Language', 'en-US');\n\n\n\nIf you are serving an HTML5 document, you should provide the character set like\nthis:\n\n\n// setting character set in HTML5\n$this->headMeta()->setCharset('UTF-8'); // Will look like <meta charset=\"UTF-8\">\n\n\n\nAs a final example, an easy way to display a transitional message before a\nredirect is using a \"meta refresh\":\n\n\n// setting a meta refresh for 3 seconds to a new url:\n$this->headMeta()\n    ->appendHttpEquiv('Refresh', '3;URL=http://www.some.org/some.html');\n\n\n\nWhen you're ready to place your meta tags in the layout, echo the helper:\n\n\n<?= $this->headMeta() ?>\n\n\n\nUsage with XHTML1_RDFA doctype\n\n\nEnabling the RDFa doctype with the \nDoctype helper\n enables the use\nof the \nproperty\n attribute (in addition to the standard \nname\n and\n\nhttp-equiv\n) with \nHeadMeta\n.  This is commonly used with the Facebook \nOpen\nGraph Protocol\n.\n\n\nFor instance, you may specify an open graph page title and type as follows:\n\n\n$this->doctype(Zend\\View\\Helper\\Doctype::XHTML1_RDFA);\n$this->headMeta()->setProperty('og:title', 'my article title');\n$this->headMeta()->setProperty('og:type', 'article');\necho $this->headMeta();\n\n// output is:\n//   <meta property=\"og:title\" content=\"my article title\" />\n//   <meta property=\"og:type\" content=\"article\" />\n\n\n\nUsage with HTML5 doctype\n\n\nEnabling the HTML5 doctype with the \nDoctype helper\n enables the use\nof the \nitemprop\n attribute (in addition to the standard \nname\n and\n\nhttp-equiv\n) with \nHeadMeta\n.  This is typically used to add\n\nMicrodata\n to the head of your document.\n\n\n$this->doctype(Zend\\View\\Helper\\Doctype::HTML5);\n$this->headMeta()->setItemprop('headline', 'My Article Headline');\n$this->headMeta()->setItemprop('dateCreated', $date->format('c'));\necho $this->headMeta();\n\n// output is:\n//   <meta itemprop=\"headline\" content=\"My Article Headline\">\n//   <meta itemprop=\"dateCreated\" content=\"2018-07-12T22:19:06+00:00\">",
            "title": "HeadMeta"
        },
        {
            "location": "/helpers/head-meta/#headmeta",
            "text": "The HTML  <meta>  element is used to provide meta information about your HTML\ndocument, typically keywords, document character set, caching pragmas, etc. Meta\ntags may be either of the  http-equiv  or  name  types, must contain a  content \nattribute, and can also have either of the  lang  or  scheme  modifier\nattributes.  The  HeadMeta  helper supports the following methods for setting and adding meta tags:   appendName($keyValue, $content, $conditionalName)  offsetSetName($index, $keyValue, $content, $conditionalName)  prependName($keyValue, $content, $conditionalName)  setName($keyValue, $content, $modifiers)  appendHttpEquiv($keyValue, $content, $conditionalHttpEquiv)  offsetSetHttpEquiv($index, $keyValue, $content, $conditionalHttpEquiv)  prependHttpEquiv($keyValue, $content, $conditionalHttpEquiv)  setHttpEquiv($keyValue, $content, $modifiers)  setCharset($charset)   The following methods are also supported with  XHTML1_RDFA  doctype set with the Doctype helper .   appendProperty($property, $content, $modifiers)  offsetSetProperty($index, $property, $content, $modifiers)  prependProperty($property, $content, $modifiers)  setProperty($property, $content, $modifiers)   Finally, starting in 2.11.2, you can call the following method to determine\nwhether or not to autoescape values used in meta tags:   setAutoEscape(bool $autoEscape = true)  (enabled by default)",
            "title": "HeadMeta"
        },
        {
            "location": "/helpers/head-meta/#autoescape",
            "text": "Disable this flag at your own risk.  The one documented case where it is\nnecessary to disable the flag is when setting the  X-UA-Compatible  http-equiv  value to switch behavior for Internet Explorer, as escaped values\nwill not trigger correct representation.   The  $keyValue  item is used to define a value for the  name  or  http-equiv \nkey;  $content  is the value for the 'content' key, and  $modifiers  is an\noptional associative array that can contain keys for  lang  and/or  scheme .  You may also set meta tags using the  headMeta()  helper method, which has the\nfollowing signature:  headMeta($content, $keyValue, $keyType = 'name',\n$modifiers = array(), $placement = 'APPEND') .   $keyValue  is the content for\nthe key specified in  $keyType , which should be either  name  or  http-equiv . $keyType  may also be specified as  property  if the doctype has been set to XHTML1_RDFA .  $placement  can be  SET  (overwrites all previously stored\nvalues),  APPEND  (added to end of stack), or  PREPEND  (added to top of stack).  HeadMeta  overrides each of  append() ,  offsetSet() ,  prepend() , and  set() \nto enforce usage of the special methods as listed above. Internally, it stores\neach item as a  stdClass  token, which it later serializes using the itemToString()  method. This allows you to perform checks on the items in the\nstack, and optionally modify these items by simply modifying the object\nreturned.  The  HeadMeta  helper is a concrete implementation of the Placeholder helper .",
            "title": "AutoEscape"
        },
        {
            "location": "/helpers/head-meta/#basic-usage",
            "text": "You may specify a new meta tag at any time. Typically, you will specify\nclient-side caching rules or SEO keywords.  For instance, if you wish to specify SEO keywords, you'd be creating a meta name\ntag with the name  keywords  and the content the keywords you wish to associate\nwith your page:  // setting meta keywords\n$this->headMeta()->appendName('keywords', 'framework, PHP, productivity');  If you wished to set some client-side caching rules, you'd set  http-equiv  tags\nwith the rules you wish to enforce:  // disabling client-side cache\n$this->headMeta()\n    ->appendHttpEquiv('expires', 'Wed, 26 Feb 1997 08:21:57 GMT')\n    ->appendHttpEquiv('pragma', 'no-cache')\n    ->appendHttpEquiv('Cache-Control', 'no-cache');  Another popular use for meta tags is setting the content type, character set,\nand language:  // setting content type and character set\n$this->headMeta()\n    ->appendHttpEquiv('Content-Type', 'text/html; charset=UTF-8')\n    ->appendHttpEquiv('Content-Language', 'en-US');  If you are serving an HTML5 document, you should provide the character set like\nthis:  // setting character set in HTML5\n$this->headMeta()->setCharset('UTF-8'); // Will look like <meta charset=\"UTF-8\">  As a final example, an easy way to display a transitional message before a\nredirect is using a \"meta refresh\":  // setting a meta refresh for 3 seconds to a new url:\n$this->headMeta()\n    ->appendHttpEquiv('Refresh', '3;URL=http://www.some.org/some.html');  When you're ready to place your meta tags in the layout, echo the helper:  <?= $this->headMeta() ?>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/head-meta/#usage-with-xhtml195rdfa-doctype",
            "text": "Enabling the RDFa doctype with the  Doctype helper  enables the use\nof the  property  attribute (in addition to the standard  name  and http-equiv ) with  HeadMeta .  This is commonly used with the Facebook  Open\nGraph Protocol .  For instance, you may specify an open graph page title and type as follows:  $this->doctype(Zend\\View\\Helper\\Doctype::XHTML1_RDFA);\n$this->headMeta()->setProperty('og:title', 'my article title');\n$this->headMeta()->setProperty('og:type', 'article');\necho $this->headMeta();\n\n// output is:\n//   <meta property=\"og:title\" content=\"my article title\" />\n//   <meta property=\"og:type\" content=\"article\" />",
            "title": "Usage with XHTML1_RDFA doctype"
        },
        {
            "location": "/helpers/head-meta/#usage-with-html5-doctype",
            "text": "Enabling the HTML5 doctype with the  Doctype helper  enables the use\nof the  itemprop  attribute (in addition to the standard  name  and http-equiv ) with  HeadMeta .  This is typically used to add Microdata  to the head of your document.  $this->doctype(Zend\\View\\Helper\\Doctype::HTML5);\n$this->headMeta()->setItemprop('headline', 'My Article Headline');\n$this->headMeta()->setItemprop('dateCreated', $date->format('c'));\necho $this->headMeta();\n\n// output is:\n//   <meta itemprop=\"headline\" content=\"My Article Headline\">\n//   <meta itemprop=\"dateCreated\" content=\"2018-07-12T22:19:06+00:00\">",
            "title": "Usage with HTML5 doctype"
        },
        {
            "location": "/helpers/head-script/",
            "text": "HeadScript\n\n\nThe HTML \n<script>\n element is used to either provide inline client-side\nscripting elements or link to a remote resource containing client-side scripting\ncode. The \nHeadScript\n helper allows you to manage both.\n\n\nThe \nHeadScript\n helper supports the following methods for setting and adding scripts:\n\n\n\n\nappendFile($src, $type = 'text/javascript', $attrs = [])\n\n\noffsetSetFile($index, $src, $type = 'text/javascript', $attrs = [])\n\n\nprependFile($src, $type = 'text/javascript', $attrs = [])\n\n\nsetFile($src, $type = 'text/javascript', $attrs = [])\n\n\nappendScript($script, $type = 'text/javascript', $attrs = [])\n\n\noffsetSetScript($index, $script, $type = 'text/javascript', $attrs = [])\n\n\nprependScript($script, $type = 'text/javascript', $attrs = [])\n\n\nsetScript($script, $type = 'text/javascript', $attrs = [])\n\n\n\n\nIn the case of the \n*File()\n methods, \n$src\n is the remote location of the\nscript to load; this is usually in the form of a URL or a path. For the\n\n*Script()\n methods, \n$script\n is the client-side scripting directives you wish\nto use in the element.\n\n\n\n\nSetting Conditional Comments\n\n\nHeadScript\n allows you to wrap the script tag in conditional comments, which\nallows you to hide it from specific browsers. To add the conditional tags,\npass the conditional value as part of the \n$attrs\n parameter in the method\ncalls.\n\n\n// adding scripts\n$this->headScript()->appendFile(\n    '/js/prototype.js',\n    'text/javascript',\n    ['conditional' => 'lt IE 7']\n);\n\n\n\nPreventing HTML style comments or CDATA wrapping of scripts\n\n\nBy default, \nHeadScript\n will wrap scripts with HTML comments or it wraps\nscripts with XHTML CDATA.  This behavior can be problematic when you intend to\nuse the script tag in an alternative way by setting the type to something\nother then \ntext/javascript\n. To prevent such escaping, pass an \nnoescape\n\nwith a value of true as part of the \n$attrs\n parameter in the method calls.\n\n\n// jquery template\n$template = '<div class=\"book\"{{:title}}</div';\n\n$this->headScript()->appendScript(\n    $template,\n    'text/x-jquery-tmpl',\n    ['id' => 'tmpl-book', 'noescape' => true]\n);\n\n\n\n\n\nHeadScript\n also allows capturing scripts; this can be useful if you want to\ncreate the client-side script programmatically, and then place it elsewhere. The\nusage for this will be showed in an example below.\n\n\nFinally, you can also use the \nheadScript()\n method to quickly add script\nelements; the signature for this is \nheadScript($mode = 'FILE', $spec = null,\n$placement = 'APPEND', array $attrs = [], $type = 'text/javascript')\n. The\n\n$mode\n is either 'FILE' or 'SCRIPT', depending on if you're linking a script or\ndefining one. \n$spec\n is either the script file to link or the script source\nitself. \n$placement\n should be either 'APPEND', 'PREPEND', or 'SET'. \n$attrs\n is\nan array of script attributes. \n$type\n is the script type attribute.\n\n\nHeadScript\n overrides each of \nappend()\n, \noffsetSet()\n, \nprepend()\n, and\n\nset()\n to enforce usage of the special methods as listed above. Internally, it\nstores each item as a \nstdClass\n token, which it later serializes using the\n\nitemToString()\n method. This allows you to perform checks on the items in the\nstack, and optionally modify these items by modifying the object returned.\n\n\nThe \nHeadScript\n helper is a concrete implementation of the\n\nPlaceholder helper\n.\n\n\n\n\nUse InlineScript for HTML Body Scripts\n\n\nHeadScript\n's sibling helper, \nInlineScript\n, should be\nused when you wish to include scripts inline in the HTML \nbody\n. Placing\nscripts at the end of your document is a good practice for speeding up\ndelivery of your page, particularly when using 3rd party analytics scripts.\n\n\nArbitrary Attributes are Disabled by Default\n\n\nBy default, \nHeadScript\n only will render \n<script>\n attributes that are blessed by the W3C.\nThese include \nid\n, \ncharset\n, \ncrossorigin\n, \ndefer\n, \nintegrity\n,\n\nlanguage\n, \nsrc\n, and \ntype\n. However, some JavaScript frameworks, notably\n\nDojo\n, utilize custom attributes in order to\nmodify behavior. To allow such attributes, you can enable them via the\n\nsetAllowArbitraryAttributes()\n method:\n\n\n$this->headScript()->setAllowArbitraryAttributes(true);\n\n\n\n\n\nBasic Usage\n\n\nYou may specify a new script tag at any time. As noted above, these may be links\nto outside resource files or scripts themselves.\n\n\n// adding scripts\n$this->headScript()\n    ->appendFile('/js/prototype.js')\n    ->appendScript($onloadScript);\n\n\n\nOrder is often important with client-side scripting; you may need to ensure that\nlibraries are loaded in a specific order due to dependencies each have; use the\nvarious \nappend\n, \nprepend\n, and \noffsetSet\n directives to aid in this task:\n\n\n// Putting scripts in order\n\n// place at a particular offset to ensure loaded last\n$this->headScript()->offsetSetFile(100, '/js/myfuncs.js');\n\n// use scriptaculous effects (append uses next index, 101)\n$this->headScript()->appendFile('/js/scriptaculous.js');\n\n// but always have base prototype script load first:\n$this->headScript()->prependFile('/js/prototype.js');\n\n\n\nWhen you're finally ready to output all scripts in your layout script, simply\necho the helper:\n\n\n<?= $this->headScript() ?>\n\n\n\nCapturing Scripts\n\n\nSometimes you need to generate client-side scripts programmatically. While you\ncould use string concatenation, heredocs, and the like, often it's easier just\nto do so by creating the script and sprinkling in PHP tags. \nHeadScript\n lets\nyou do just that, capturing it to the stack:\n\n\n<?php $this->headScript()->captureStart() ?>\nvar action = '<?= $this->baseUrl ?>';\n$('foo_form').action = action;\n<?php $this->headScript()->captureEnd() ?>\n\n\n\nThe following assumptions are made:\n\n\n\n\nThe script will be appended to the stack. If you wish for it to replace the\n  stack or be added to the top, you will need to pass 'SET' or 'PREPEND',\n  respectively, as the first argument to \ncaptureStart()\n.\n\n\nThe script MIME type is assumed to be \ntext/javascript\n; if you wish to\n  specify a different type, you will need to pass it as the second argument to\n  \ncaptureStart()\n.\n\n\nIf you wish to specify any additional attributes for the \n<script>\n tag, pass\n  them in an array as the third argument to \ncaptureStart()\n.",
            "title": "HeadScript"
        },
        {
            "location": "/helpers/head-script/#headscript",
            "text": "The HTML  <script>  element is used to either provide inline client-side\nscripting elements or link to a remote resource containing client-side scripting\ncode. The  HeadScript  helper allows you to manage both.  The  HeadScript  helper supports the following methods for setting and adding scripts:   appendFile($src, $type = 'text/javascript', $attrs = [])  offsetSetFile($index, $src, $type = 'text/javascript', $attrs = [])  prependFile($src, $type = 'text/javascript', $attrs = [])  setFile($src, $type = 'text/javascript', $attrs = [])  appendScript($script, $type = 'text/javascript', $attrs = [])  offsetSetScript($index, $script, $type = 'text/javascript', $attrs = [])  prependScript($script, $type = 'text/javascript', $attrs = [])  setScript($script, $type = 'text/javascript', $attrs = [])   In the case of the  *File()  methods,  $src  is the remote location of the\nscript to load; this is usually in the form of a URL or a path. For the *Script()  methods,  $script  is the client-side scripting directives you wish\nto use in the element.",
            "title": "HeadScript"
        },
        {
            "location": "/helpers/head-script/#setting-conditional-comments",
            "text": "HeadScript  allows you to wrap the script tag in conditional comments, which\nallows you to hide it from specific browsers. To add the conditional tags,\npass the conditional value as part of the  $attrs  parameter in the method\ncalls.  // adding scripts\n$this->headScript()->appendFile(\n    '/js/prototype.js',\n    'text/javascript',\n    ['conditional' => 'lt IE 7']\n);",
            "title": "Setting Conditional Comments"
        },
        {
            "location": "/helpers/head-script/#preventing-html-style-comments-or-cdata-wrapping-of-scripts",
            "text": "By default,  HeadScript  will wrap scripts with HTML comments or it wraps\nscripts with XHTML CDATA.  This behavior can be problematic when you intend to\nuse the script tag in an alternative way by setting the type to something\nother then  text/javascript . To prevent such escaping, pass an  noescape \nwith a value of true as part of the  $attrs  parameter in the method calls.  // jquery template\n$template = '<div class=\"book\"{{:title}}</div';\n\n$this->headScript()->appendScript(\n    $template,\n    'text/x-jquery-tmpl',\n    ['id' => 'tmpl-book', 'noescape' => true]\n);   HeadScript  also allows capturing scripts; this can be useful if you want to\ncreate the client-side script programmatically, and then place it elsewhere. The\nusage for this will be showed in an example below.  Finally, you can also use the  headScript()  method to quickly add script\nelements; the signature for this is  headScript($mode = 'FILE', $spec = null,\n$placement = 'APPEND', array $attrs = [], $type = 'text/javascript') . The $mode  is either 'FILE' or 'SCRIPT', depending on if you're linking a script or\ndefining one.  $spec  is either the script file to link or the script source\nitself.  $placement  should be either 'APPEND', 'PREPEND', or 'SET'.  $attrs  is\nan array of script attributes.  $type  is the script type attribute.  HeadScript  overrides each of  append() ,  offsetSet() ,  prepend() , and set()  to enforce usage of the special methods as listed above. Internally, it\nstores each item as a  stdClass  token, which it later serializes using the itemToString()  method. This allows you to perform checks on the items in the\nstack, and optionally modify these items by modifying the object returned.  The  HeadScript  helper is a concrete implementation of the Placeholder helper .",
            "title": "Preventing HTML style comments or CDATA wrapping of scripts"
        },
        {
            "location": "/helpers/head-script/#use-inlinescript-for-html-body-scripts",
            "text": "HeadScript 's sibling helper,  InlineScript , should be\nused when you wish to include scripts inline in the HTML  body . Placing\nscripts at the end of your document is a good practice for speeding up\ndelivery of your page, particularly when using 3rd party analytics scripts.",
            "title": "Use InlineScript for HTML Body Scripts"
        },
        {
            "location": "/helpers/head-script/#arbitrary-attributes-are-disabled-by-default",
            "text": "By default,  HeadScript  only will render  <script>  attributes that are blessed by the W3C.\nThese include  id ,  charset ,  crossorigin ,  defer ,  integrity , language ,  src , and  type . However, some JavaScript frameworks, notably Dojo , utilize custom attributes in order to\nmodify behavior. To allow such attributes, you can enable them via the setAllowArbitraryAttributes()  method:  $this->headScript()->setAllowArbitraryAttributes(true);",
            "title": "Arbitrary Attributes are Disabled by Default"
        },
        {
            "location": "/helpers/head-script/#basic-usage",
            "text": "You may specify a new script tag at any time. As noted above, these may be links\nto outside resource files or scripts themselves.  // adding scripts\n$this->headScript()\n    ->appendFile('/js/prototype.js')\n    ->appendScript($onloadScript);  Order is often important with client-side scripting; you may need to ensure that\nlibraries are loaded in a specific order due to dependencies each have; use the\nvarious  append ,  prepend , and  offsetSet  directives to aid in this task:  // Putting scripts in order\n\n// place at a particular offset to ensure loaded last\n$this->headScript()->offsetSetFile(100, '/js/myfuncs.js');\n\n// use scriptaculous effects (append uses next index, 101)\n$this->headScript()->appendFile('/js/scriptaculous.js');\n\n// but always have base prototype script load first:\n$this->headScript()->prependFile('/js/prototype.js');  When you're finally ready to output all scripts in your layout script, simply\necho the helper:  <?= $this->headScript() ?>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/head-script/#capturing-scripts",
            "text": "Sometimes you need to generate client-side scripts programmatically. While you\ncould use string concatenation, heredocs, and the like, often it's easier just\nto do so by creating the script and sprinkling in PHP tags.  HeadScript  lets\nyou do just that, capturing it to the stack:  <?php $this->headScript()->captureStart() ?>\nvar action = '<?= $this->baseUrl ?>';\n$('foo_form').action = action;\n<?php $this->headScript()->captureEnd() ?>  The following assumptions are made:   The script will be appended to the stack. If you wish for it to replace the\n  stack or be added to the top, you will need to pass 'SET' or 'PREPEND',\n  respectively, as the first argument to  captureStart() .  The script MIME type is assumed to be  text/javascript ; if you wish to\n  specify a different type, you will need to pass it as the second argument to\n   captureStart() .  If you wish to specify any additional attributes for the  <script>  tag, pass\n  them in an array as the third argument to  captureStart() .",
            "title": "Capturing Scripts"
        },
        {
            "location": "/helpers/head-style/",
            "text": "HeadStyle\n\n\nThe HTML \n<style>\n element is used to include CSS stylesheets inline in the HTML\n\n<head>\n element.\n\n\n\n\nUse HeadLink to link CSS files\n\n\nHeadLink\n should be used to create \n<link>\n elements for\nincluding external stylesheets. \nHeadStyle\n is used when you wish to define\nyour stylesheets inline.\n\n\n\n\nThe \nHeadStyle\n helper supports the following methods for setting and adding stylesheet\ndeclarations:\n\n\n\n\nappendStyle($content, $attributes = [])\n\n\noffsetSetStyle($index, $content, $attributes = [])\n\n\nprependStyle($content, $attributes = [])\n\n\nsetStyle($content, $attributes = [])\n\n\n\n\nIn all cases, \n$content\n is the actual CSS declarations. \n$attributes\n are any\nadditional attributes you wish to provide to the \nstyle\n tag: lang, title,\nmedia, or dir are all permissible.\n\n\n\n\nSetting Conditional Comments\n\n\nHeadStyle\n allows you to wrap the style tag in conditional comments, which\nallows you to hide it from specific browsers. To add the conditional tags,\npass the conditional value as part of the \n$attributes\n parameter in the\nmethod calls.\n\n\n// adding comments\n$this->headStyle()->appendStyle($styles, ['conditional' => 'lt IE 7']);\n\n\n\n\n\nHeadStyle\n also allows capturing style declarations; this can be useful if you\nwant to create the declarations programmatically, and then place them elsewhere.\nThe usage for this will be showed in an example below.\n\n\nFinally, you can also use the \nheadStyle()\n method to quickly add declarations\nelements; the signature for this is \nheadStyle($content = null, $placement =\n'APPEND', $attributes = array())\n.  \n$placement\n should be either \nAPPEND\n,\n\nPREPEND\n, or \nSET\n.\n\n\nHeadStyle\n overrides each of \nappend()\n, \noffsetSet()\n, \nprepend()\n, and\n\nset()\n to enforce usage of the special methods as listed above. Internally, it\nstores each item as a \nstdClass\n token, which it later serializes using the\n\nitemToString()\n method. This allows you to perform checks on the items in the\nstack, and optionally modify these items by modifying the object returned.\n\n\nThe \nHeadStyle\n helper is a concrete implementation of the\n\nPlaceholder helper\n.\n\n\n\n\nUTF-8 encoding used by default\n\n\nBy default, zend-view uses \nUTF-8\n as its default encoding.  If you want to\nuse another encoding with \nheadStyle\n, you must:\n\n\n\n\nCreate a custom renderer and implement a \ngetEncoding()\n method;\n\n\nCreate a custom rendering strategy that will return an instance of your custom renderer;\n\n\nAttach the custom strategy in the \nViewEvent\n.\n\n\n\n\nFirst we have to write the custom renderer:\n\n\n// module/MyModule/View/Renderer/MyRenderer.php\nnamespace MyModule\\View\\Renderer;\n\n// Since we just want to implement the getEncoding() method, we can extend the Zend native renderer\nuse Zend\\View\\Renderer\\PhpRenderer;\n\nclass MyRenderer extends PhpRenderer\n{\n   /**\n    * @var string\n    */\n   protected $encoding;\n\n   /**\n    * Constructor\n    *\n    * @param  string $encoding The encoding to be used\n    */\n   public function __construct($encoding)\n   {\n      parent::__construct();\n      $this->encoding = $encoding;\n   }\n\n   /**\n    * Sets the encoding\n    *\n    * @param string $encoding The encoding to be used\n    */\n   public function setEncoding($encoding)\n   {\n      $this->encoding = $encoding;\n   }\n\n   /**\n    * Gets the encoding\n    *\n    * @return string The encoding being used\n    */\n   public function getEncoding()\n   {\n      return $this->encoding;\n   }\n}\n\n\n\nNow we make some configuration in the module class:\n\n\n// module/MyModule.php\nnamespace MyModule;\n\nuse MyModule\\View\\Renderer\\MyRenderer;\nuse Zend\\Mvc\\MvcEvent;\nuse Zend\\View\\Strategy\\PhpRendererStrategy;\n\nclass Module\n{\n   public function getConfig(){/* ... */}\n\n   public function getAutoloaderConfig(){/* ... */}\n\n   public function getServiceConfig()\n   {\n      return [\n         'factories' => [\n            // Register our custom renderer in the container\n            'MyCustomRenderer' => function ($container) {\n               return new MyRenderer('ISO-8859-1');\n            },\n            'MyCustomStrategy' => function ($container) {\n               // As stated before, we just want to implement the\n               // getEncoding() method, so we can use the base PhpRendererStrategy\n               // and provide our custom renderer to it.\n               $myRenderer = $container->get('MyCustomRenderer');\n               return new PhpRendererStrategy($myRenderer);\n            },\n         ],\n      ];\n   }\n\n   public function onBootstrap(MvcEvent $e)\n   {\n      // Register a render event\n      $app = $e->getParam('application');\n      $app->getEventManager()->attach('render', [$this, 'registerMyStrategy'], 100);\n   }\n\n    public function registerMyStrategy(MvcEvent $e)\n    {\n        $app        = $e->getTarget();\n        $locator    = $app->getServiceManager();\n        $view       = $locator->get('Zend\\View\\View');\n        $myStrategy = $locator->get('MyCustomStrategy');\n\n        // Attach strategy, which is a listener aggregate, at high priority\n        $view->getEventManager()->attach($myStrategy, 100);\n    }\n}\n\n\n\nSee the quick start \nCreating and Registering Alternate Rendering and Response Strategies\n\nchapter for more information on how to create and register custom strategies\nto your view.\n\n\n\n\nBasic Usage\n\n\nYou may specify a new style tag at any time:\n\n\n// adding styles\n$this->headStyle()->appendStyle($styles);\n\n\n\nOrder is very important with CSS; you may need to ensure that declarations are\nloaded in a specific order due to the order of the cascade; use the various\n\nappend\n, \nprepend\n, and \noffsetSet\n directives to aid in this task:\n\n\n// Putting styles in order\n\n// place at a particular offset:\n$this->headStyle()->offsetSetStyle(100, $customStyles);\n\n// place at end:\n$this->headStyle()->appendStyle($finalStyles);\n\n// place at beginning\n$this->headStyle()->prependStyle($firstStyles);\n\n\n\nWhen you're finally ready to output all style declarations in your layout\nscript, echo the helper:\n\n\n<?= $this->headStyle() ?>\n\n\n\nCapturing Style Declarations\n\n\nSometimes you need to generate CSS style declarations programmatically. While\nyou could use string concatenation, heredocs, and the like, often it's easier\njust to do so by creating the styles and sprinkling in PHP tags. \nHeadStyle\n\nlets you do just that, capturing it to the stack:\n\n\n<?php $this->headStyle()->captureStart() ?>\nbody {\n    background-color: <?= $this->bgColor ?>;\n}\n<?php $this->headStyle()->captureEnd() ?>\n\n\n\nThe following assumptions are made:\n\n\n\n\nThe style declarations will be appended to the stack. If you wish for them to\n  replace the stack or be added to the top, you will need to pass \nSET\n or\n  \nPREPEND\n, respectively, as the first argument to \ncaptureStart()\n.\n\n\nIf you wish to specify any additional attributes for the \n<style>\n tag, pass\n  them in an array as the second argument to \ncaptureStart()\n.",
            "title": "HeadStyle"
        },
        {
            "location": "/helpers/head-style/#headstyle",
            "text": "The HTML  <style>  element is used to include CSS stylesheets inline in the HTML <head>  element.",
            "title": "HeadStyle"
        },
        {
            "location": "/helpers/head-style/#use-headlink-to-link-css-files",
            "text": "HeadLink  should be used to create  <link>  elements for\nincluding external stylesheets.  HeadStyle  is used when you wish to define\nyour stylesheets inline.   The  HeadStyle  helper supports the following methods for setting and adding stylesheet\ndeclarations:   appendStyle($content, $attributes = [])  offsetSetStyle($index, $content, $attributes = [])  prependStyle($content, $attributes = [])  setStyle($content, $attributes = [])   In all cases,  $content  is the actual CSS declarations.  $attributes  are any\nadditional attributes you wish to provide to the  style  tag: lang, title,\nmedia, or dir are all permissible.",
            "title": "Use HeadLink to link CSS files"
        },
        {
            "location": "/helpers/head-style/#setting-conditional-comments",
            "text": "HeadStyle  allows you to wrap the style tag in conditional comments, which\nallows you to hide it from specific browsers. To add the conditional tags,\npass the conditional value as part of the  $attributes  parameter in the\nmethod calls.  // adding comments\n$this->headStyle()->appendStyle($styles, ['conditional' => 'lt IE 7']);   HeadStyle  also allows capturing style declarations; this can be useful if you\nwant to create the declarations programmatically, and then place them elsewhere.\nThe usage for this will be showed in an example below.  Finally, you can also use the  headStyle()  method to quickly add declarations\nelements; the signature for this is  headStyle($content = null, $placement =\n'APPEND', $attributes = array()) .   $placement  should be either  APPEND , PREPEND , or  SET .  HeadStyle  overrides each of  append() ,  offsetSet() ,  prepend() , and set()  to enforce usage of the special methods as listed above. Internally, it\nstores each item as a  stdClass  token, which it later serializes using the itemToString()  method. This allows you to perform checks on the items in the\nstack, and optionally modify these items by modifying the object returned.  The  HeadStyle  helper is a concrete implementation of the Placeholder helper .",
            "title": "Setting Conditional Comments"
        },
        {
            "location": "/helpers/head-style/#utf-8-encoding-used-by-default",
            "text": "By default, zend-view uses  UTF-8  as its default encoding.  If you want to\nuse another encoding with  headStyle , you must:   Create a custom renderer and implement a  getEncoding()  method;  Create a custom rendering strategy that will return an instance of your custom renderer;  Attach the custom strategy in the  ViewEvent .   First we have to write the custom renderer:  // module/MyModule/View/Renderer/MyRenderer.php\nnamespace MyModule\\View\\Renderer;\n\n// Since we just want to implement the getEncoding() method, we can extend the Zend native renderer\nuse Zend\\View\\Renderer\\PhpRenderer;\n\nclass MyRenderer extends PhpRenderer\n{\n   /**\n    * @var string\n    */\n   protected $encoding;\n\n   /**\n    * Constructor\n    *\n    * @param  string $encoding The encoding to be used\n    */\n   public function __construct($encoding)\n   {\n      parent::__construct();\n      $this->encoding = $encoding;\n   }\n\n   /**\n    * Sets the encoding\n    *\n    * @param string $encoding The encoding to be used\n    */\n   public function setEncoding($encoding)\n   {\n      $this->encoding = $encoding;\n   }\n\n   /**\n    * Gets the encoding\n    *\n    * @return string The encoding being used\n    */\n   public function getEncoding()\n   {\n      return $this->encoding;\n   }\n}  Now we make some configuration in the module class:  // module/MyModule.php\nnamespace MyModule;\n\nuse MyModule\\View\\Renderer\\MyRenderer;\nuse Zend\\Mvc\\MvcEvent;\nuse Zend\\View\\Strategy\\PhpRendererStrategy;\n\nclass Module\n{\n   public function getConfig(){/* ... */}\n\n   public function getAutoloaderConfig(){/* ... */}\n\n   public function getServiceConfig()\n   {\n      return [\n         'factories' => [\n            // Register our custom renderer in the container\n            'MyCustomRenderer' => function ($container) {\n               return new MyRenderer('ISO-8859-1');\n            },\n            'MyCustomStrategy' => function ($container) {\n               // As stated before, we just want to implement the\n               // getEncoding() method, so we can use the base PhpRendererStrategy\n               // and provide our custom renderer to it.\n               $myRenderer = $container->get('MyCustomRenderer');\n               return new PhpRendererStrategy($myRenderer);\n            },\n         ],\n      ];\n   }\n\n   public function onBootstrap(MvcEvent $e)\n   {\n      // Register a render event\n      $app = $e->getParam('application');\n      $app->getEventManager()->attach('render', [$this, 'registerMyStrategy'], 100);\n   }\n\n    public function registerMyStrategy(MvcEvent $e)\n    {\n        $app        = $e->getTarget();\n        $locator    = $app->getServiceManager();\n        $view       = $locator->get('Zend\\View\\View');\n        $myStrategy = $locator->get('MyCustomStrategy');\n\n        // Attach strategy, which is a listener aggregate, at high priority\n        $view->getEventManager()->attach($myStrategy, 100);\n    }\n}  See the quick start  Creating and Registering Alternate Rendering and Response Strategies \nchapter for more information on how to create and register custom strategies\nto your view.",
            "title": "UTF-8 encoding used by default"
        },
        {
            "location": "/helpers/head-style/#basic-usage",
            "text": "You may specify a new style tag at any time:  // adding styles\n$this->headStyle()->appendStyle($styles);  Order is very important with CSS; you may need to ensure that declarations are\nloaded in a specific order due to the order of the cascade; use the various append ,  prepend , and  offsetSet  directives to aid in this task:  // Putting styles in order\n\n// place at a particular offset:\n$this->headStyle()->offsetSetStyle(100, $customStyles);\n\n// place at end:\n$this->headStyle()->appendStyle($finalStyles);\n\n// place at beginning\n$this->headStyle()->prependStyle($firstStyles);  When you're finally ready to output all style declarations in your layout\nscript, echo the helper:  <?= $this->headStyle() ?>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/head-style/#capturing-style-declarations",
            "text": "Sometimes you need to generate CSS style declarations programmatically. While\nyou could use string concatenation, heredocs, and the like, often it's easier\njust to do so by creating the styles and sprinkling in PHP tags.  HeadStyle \nlets you do just that, capturing it to the stack:  <?php $this->headStyle()->captureStart() ?>\nbody {\n    background-color: <?= $this->bgColor ?>;\n}\n<?php $this->headStyle()->captureEnd() ?>  The following assumptions are made:   The style declarations will be appended to the stack. If you wish for them to\n  replace the stack or be added to the top, you will need to pass  SET  or\n   PREPEND , respectively, as the first argument to  captureStart() .  If you wish to specify any additional attributes for the  <style>  tag, pass\n  them in an array as the second argument to  captureStart() .",
            "title": "Capturing Style Declarations"
        },
        {
            "location": "/helpers/head-title/",
            "text": "HeadTitle\n\n\nThe HTML \n<title>\n element is used to provide a title for an HTML document. The\n\nHeadTitle\n helper allows you to programmatically create and store the title for\nlater retrieval and output.\n\n\nThe \nHeadTitle\n helper is a concrete implementation of the \nPlaceholder helper\n.\nIt overrides the \ntoString()\n method to enforce generating a \n<title>\n element,\nand adds a \nheadTitle()\n method for overwriting and aggregation of title\nelements. The signature for that method is \nheadTitle($title, $setType = null)\n;\nby default, the value is appended to the stack (aggregating title segments) if\nleft at \nnull\n, but you may also specify either 'PREPEND' (place at top of\nstack) or 'SET' (overwrite stack).\n\n\nSince setting the aggregating (attach) order on each call to \nheadTitle\n can be\ncumbersome, you can set a default attach order by calling\n\nsetDefaultAttachOrder()\n which is applied to all \nheadTitle()\n calls unless you\nexplicitly pass a different attach order as the second parameter.\n\n\nBasic Usage\n\n\nYou may specify a title tag at any time. A typical usage would have you setting\ntitle segments for each level of depth in your application: site, module,\ncontroller, action, and potentially resource. This could be achieved in the\nmodule class.\n\n\n// module/MyModule/Module.php\n<?php\n\nnamespace MyModule;\n\nclass Module\n{\n    /**\n     * @param  \\Zend\\Mvc\\MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap($e)\n    {\n        // Register a render event\n        $app = $e->getParam('application');\n        $app->getEventManager()->attach('render', [$this, 'setLayoutTitle']);\n    }\n\n    /**\n     * @param  \\Zend\\Mvc\\MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function setLayoutTitle($e)\n    {\n        $matches    = $e->getRouteMatch();\n        $action     = $matches->getParam('action');\n        $controller = $matches->getParam('controller');\n        $module     = __NAMESPACE__;\n        $siteName   = 'Zend Framework';\n\n        // Getting the view helper manager from the application service manager\n        $viewHelperManager = $e->getApplication()->getServiceManager()->get('ViewHelperManager');\n\n        // Getting the headTitle helper from the view helper manager\n        $headTitleHelper = $viewHelperManager->get('headTitle');\n\n        // Setting a separator string for segments\n        $headTitleHelper->setSeparator(' - ');\n\n        // Setting the action, controller, module and site name as title segments\n        $headTitleHelper->append($action);\n        $headTitleHelper->append($controller);\n        $headTitleHelper->append($module);\n        $headTitleHelper->append($siteName);\n    }\n}\n\n\n\nWhen you're finally ready to render the title in your layout script, echo the\nhelper:\n\n\n<?= $this->headTitle() ?>\n\n\n\nOutput:\n\n\n<title>action - controller - module - Zend Framework</title>\n\n\n\nIn case you want the title without the \n<title>\n and \n</title>\n tags you can use\nthe \nrenderTitle()\n method:\n\n\n<?= $this->headTitle()->renderTitle() ?>\n\n\n\nOutput:\n\n\naction - controller - module - Zend Framework",
            "title": "HeadTitle"
        },
        {
            "location": "/helpers/head-title/#headtitle",
            "text": "The HTML  <title>  element is used to provide a title for an HTML document. The HeadTitle  helper allows you to programmatically create and store the title for\nlater retrieval and output.  The  HeadTitle  helper is a concrete implementation of the  Placeholder helper .\nIt overrides the  toString()  method to enforce generating a  <title>  element,\nand adds a  headTitle()  method for overwriting and aggregation of title\nelements. The signature for that method is  headTitle($title, $setType = null) ;\nby default, the value is appended to the stack (aggregating title segments) if\nleft at  null , but you may also specify either 'PREPEND' (place at top of\nstack) or 'SET' (overwrite stack).  Since setting the aggregating (attach) order on each call to  headTitle  can be\ncumbersome, you can set a default attach order by calling setDefaultAttachOrder()  which is applied to all  headTitle()  calls unless you\nexplicitly pass a different attach order as the second parameter.",
            "title": "HeadTitle"
        },
        {
            "location": "/helpers/head-title/#basic-usage",
            "text": "You may specify a title tag at any time. A typical usage would have you setting\ntitle segments for each level of depth in your application: site, module,\ncontroller, action, and potentially resource. This could be achieved in the\nmodule class.  // module/MyModule/Module.php\n<?php\n\nnamespace MyModule;\n\nclass Module\n{\n    /**\n     * @param  \\Zend\\Mvc\\MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap($e)\n    {\n        // Register a render event\n        $app = $e->getParam('application');\n        $app->getEventManager()->attach('render', [$this, 'setLayoutTitle']);\n    }\n\n    /**\n     * @param  \\Zend\\Mvc\\MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function setLayoutTitle($e)\n    {\n        $matches    = $e->getRouteMatch();\n        $action     = $matches->getParam('action');\n        $controller = $matches->getParam('controller');\n        $module     = __NAMESPACE__;\n        $siteName   = 'Zend Framework';\n\n        // Getting the view helper manager from the application service manager\n        $viewHelperManager = $e->getApplication()->getServiceManager()->get('ViewHelperManager');\n\n        // Getting the headTitle helper from the view helper manager\n        $headTitleHelper = $viewHelperManager->get('headTitle');\n\n        // Setting a separator string for segments\n        $headTitleHelper->setSeparator(' - ');\n\n        // Setting the action, controller, module and site name as title segments\n        $headTitleHelper->append($action);\n        $headTitleHelper->append($controller);\n        $headTitleHelper->append($module);\n        $headTitleHelper->append($siteName);\n    }\n}  When you're finally ready to render the title in your layout script, echo the\nhelper:  <?= $this->headTitle() ?>  Output:  <title>action - controller - module - Zend Framework</title>  In case you want the title without the  <title>  and  </title>  tags you can use\nthe  renderTitle()  method:  <?= $this->headTitle()->renderTitle() ?>  Output:  action - controller - module - Zend Framework",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/html-list/",
            "text": "HtmlList\n\n\nhtmlList($items, $ordered, $attribs, $escape)\n generates unordered and ordered\nlists based on the \n$items\n passed to it. If \n$items\n is a multidimensional\narray, a nested list will be built. If the \n$escape\n flag is \ntrue\n (default),\nindividual items will be escaped using the view objects registered escaping\nmechanisms; pass a \nfalse\n value if you want to allow markup in your lists.\n\n\nBasic Usage\n\n\nUnordered list\n\n\n$items = [\n    'Level one, number one',\n    [\n        'Level two, number one',\n        'Level two, number two',\n        [\n            'Level three, number one'\n        ],\n        'Level two, number three',\n    ],\n    'Level one, number two',\n];\n\necho $this->htmlList($items);\n\n\n\nOutput:\n\n\n<ul>\n    <li>Level one, number one\n        <ul>\n            <li>Level two, number one</li>\n            <li>Level two, number two\n                <ul>\n                    <li>Level three, number one</li>\n                </ul>\n            </li>\n            <li>Level two, number three</li>\n        </ul>\n    </li>\n    <li>Level one, number two</li>\n</ul>\n\n\n\nOrdered list\n\n\necho $this->htmlList($items, true);\n\n\n\nOutput:\n\n\n<ol>\n    <li>Level one, number one\n        <ol>\n            <li>Level two, number one</li>\n            <li>Level two, number two\n                <ol>\n                    <li>Level three, number one</li>\n                </ol>\n            </li>\n            <li>Level two, number three</li>\n        </ol>\n    </li>\n    <li>Level one, number two</li>\n</ol>\n\n\n\nHTML attributes\n\n\n$attribs = ['class' => 'foo'];\n\necho $this->htmlList($items, false, $attribs);\n\n\n\nOutput:\n\n\n<ul class=\"foo\">\n    <li>Level one, number one\n        <ul class=\"foo\">\n            <li>Level two, number one</li>\n            <li>Level two, number two\n                <ul class=\"foo\">\n                    <li>Level three, number one</li>\n                </ul>\n            </li>\n            <li>Level two, number three</li>\n        </ul>\n    </li>\n    <li>Level one, number two</li>\n</ul>\n\n\n\nEscape Output\n\n\n$items = [\n    'Level one, number <strong>one</strong>',\n    'Level one, number <em>two</em>',\n];\n\n// Escape output (default)\necho $this->htmlList($items);\n\n// Don't escape output\necho $this->htmlList($items, false, false, false);\n\n\n\nOutput:\n\n\n<!-- Escape output (default) -->\n<ul class=\"foo\">\n    <li>Level one, number &lt;strong&gt;one&lt;/strong&gt;</li>\n    <li>Level one, number &lt;em&gt;two&lt;/em&gt;</li>\n</ul>\n\n<!-- Don't escape output -->\n<ul class=\"foo\">\n    <li>Level one, number <strong>one</strong></li>\n    <li>Level one, number <em>two</em></li>\n</ul>",
            "title": "HtmlList"
        },
        {
            "location": "/helpers/html-list/#htmllist",
            "text": "htmlList($items, $ordered, $attribs, $escape)  generates unordered and ordered\nlists based on the  $items  passed to it. If  $items  is a multidimensional\narray, a nested list will be built. If the  $escape  flag is  true  (default),\nindividual items will be escaped using the view objects registered escaping\nmechanisms; pass a  false  value if you want to allow markup in your lists.",
            "title": "HtmlList"
        },
        {
            "location": "/helpers/html-list/#basic-usage",
            "text": "",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/html-list/#unordered-list",
            "text": "$items = [\n    'Level one, number one',\n    [\n        'Level two, number one',\n        'Level two, number two',\n        [\n            'Level three, number one'\n        ],\n        'Level two, number three',\n    ],\n    'Level one, number two',\n];\n\necho $this->htmlList($items);  Output:  <ul>\n    <li>Level one, number one\n        <ul>\n            <li>Level two, number one</li>\n            <li>Level two, number two\n                <ul>\n                    <li>Level three, number one</li>\n                </ul>\n            </li>\n            <li>Level two, number three</li>\n        </ul>\n    </li>\n    <li>Level one, number two</li>\n</ul>",
            "title": "Unordered list"
        },
        {
            "location": "/helpers/html-list/#ordered-list",
            "text": "echo $this->htmlList($items, true);  Output:  <ol>\n    <li>Level one, number one\n        <ol>\n            <li>Level two, number one</li>\n            <li>Level two, number two\n                <ol>\n                    <li>Level three, number one</li>\n                </ol>\n            </li>\n            <li>Level two, number three</li>\n        </ol>\n    </li>\n    <li>Level one, number two</li>\n</ol>",
            "title": "Ordered list"
        },
        {
            "location": "/helpers/html-list/#html-attributes",
            "text": "$attribs = ['class' => 'foo'];\n\necho $this->htmlList($items, false, $attribs);  Output:  <ul class=\"foo\">\n    <li>Level one, number one\n        <ul class=\"foo\">\n            <li>Level two, number one</li>\n            <li>Level two, number two\n                <ul class=\"foo\">\n                    <li>Level three, number one</li>\n                </ul>\n            </li>\n            <li>Level two, number three</li>\n        </ul>\n    </li>\n    <li>Level one, number two</li>\n</ul>",
            "title": "HTML attributes"
        },
        {
            "location": "/helpers/html-list/#escape-output",
            "text": "$items = [\n    'Level one, number <strong>one</strong>',\n    'Level one, number <em>two</em>',\n];\n\n// Escape output (default)\necho $this->htmlList($items);\n\n// Don't escape output\necho $this->htmlList($items, false, false, false);  Output:  <!-- Escape output (default) -->\n<ul class=\"foo\">\n    <li>Level one, number &lt;strong&gt;one&lt;/strong&gt;</li>\n    <li>Level one, number &lt;em&gt;two&lt;/em&gt;</li>\n</ul>\n\n<!-- Don't escape output -->\n<ul class=\"foo\">\n    <li>Level one, number <strong>one</strong></li>\n    <li>Level one, number <em>two</em></li>\n</ul>",
            "title": "Escape Output"
        },
        {
            "location": "/helpers/html-object/",
            "text": "HTML Object\n\n\nThe HTML \n<object>\n element is used for embedding media like Flash or QuickTime\nin web pages. The object view helpers take care of embedding media with minimum\neffort.\n\n\nThere are four initial Object helpers:\n\n\n\n\nhtmlFlash()\n Generates markup for embedding Flash files.\n\n\nhtmlObject()\n Generates markup for embedding a custom Object.\n\n\nhtmlPage()\n Generates markup for embedding other (X)HTML pages.\n\n\nhtmlQuicktime()\n Generates markup for embedding QuickTime files.\n\n\n\n\nAll of these helpers share a similar interface. For this reason, this\ndocumentation will only contain examples of two of these helpers.\n\n\nFlash helper\n\n\nEmbedding Flash in your page using the helper only requires the resource URI.\n\n\n<?= $this->htmlFlash('/path/to/flash.swf'); ?>\n\n\n\nThis outputs the following HTML:\n\n\n<object data=\"/path/to/flash.swf\"\n        type=\"application/x-shockwave-flash\"\n        classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n        codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab\">\n</object>\n\n\n\nAdditionally, you can specify attributes, parameters, and content that can be\nrendered along with the \n<object>\n. This will be demonstrated using the\n\nhtmlObject()\n helper.\n\n\nCustomizing the object by passing additional arguments\n\n\nThe first argument in the object helpers is always required. It is the URI to\nthe resource you want to embed. The second argument is only required in the\n\nhtmlObject()\n helper. The other helpers already contain the correct value for\nthis argument. The third argument is used for passing along attributes to the\nobject element. It only accepts an array with key-value pairs. \nclassid\n and\n\ncodebase\n are examples of such attributes. The fourth argument also only takes\na key-value array and uses them to create \n<param>\n elements. You will see an\nexample of this shortly. Lastly, there is the option of providing additional\ncontent to the object. The following example utilizes all arguments.\n\n\necho $this->htmlObject(\n    '/path/to/file.ext',\n    'mime/type',\n    [\n        'attr1' => 'aval1',\n        'attr2' => 'aval2',\n    ],\n    [\n        'param1' => 'pval1',\n        'param2' => 'pval2',\n    ],\n    'some content'\n);\n\n\n\nThis would output:\n\n\n<object data=\"/path/to/file.ext\" type=\"mime/type\"\n    attr1=\"aval1\" attr2=\"aval2\">\n    <param name=\"param1\" value=\"pval1\" />\n    <param name=\"param2\" value=\"pval2\" />\n    some content\n</object>",
            "title": "HtmlObject"
        },
        {
            "location": "/helpers/html-object/#html-object",
            "text": "The HTML  <object>  element is used for embedding media like Flash or QuickTime\nin web pages. The object view helpers take care of embedding media with minimum\neffort.  There are four initial Object helpers:   htmlFlash()  Generates markup for embedding Flash files.  htmlObject()  Generates markup for embedding a custom Object.  htmlPage()  Generates markup for embedding other (X)HTML pages.  htmlQuicktime()  Generates markup for embedding QuickTime files.   All of these helpers share a similar interface. For this reason, this\ndocumentation will only contain examples of two of these helpers.",
            "title": "HTML Object"
        },
        {
            "location": "/helpers/html-object/#flash-helper",
            "text": "Embedding Flash in your page using the helper only requires the resource URI.  <?= $this->htmlFlash('/path/to/flash.swf'); ?>  This outputs the following HTML:  <object data=\"/path/to/flash.swf\"\n        type=\"application/x-shockwave-flash\"\n        classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n        codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab\">\n</object>  Additionally, you can specify attributes, parameters, and content that can be\nrendered along with the  <object> . This will be demonstrated using the htmlObject()  helper.",
            "title": "Flash helper"
        },
        {
            "location": "/helpers/html-object/#customizing-the-object-by-passing-additional-arguments",
            "text": "The first argument in the object helpers is always required. It is the URI to\nthe resource you want to embed. The second argument is only required in the htmlObject()  helper. The other helpers already contain the correct value for\nthis argument. The third argument is used for passing along attributes to the\nobject element. It only accepts an array with key-value pairs.  classid  and codebase  are examples of such attributes. The fourth argument also only takes\na key-value array and uses them to create  <param>  elements. You will see an\nexample of this shortly. Lastly, there is the option of providing additional\ncontent to the object. The following example utilizes all arguments.  echo $this->htmlObject(\n    '/path/to/file.ext',\n    'mime/type',\n    [\n        'attr1' => 'aval1',\n        'attr2' => 'aval2',\n    ],\n    [\n        'param1' => 'pval1',\n        'param2' => 'pval2',\n    ],\n    'some content'\n);  This would output:  <object data=\"/path/to/file.ext\" type=\"mime/type\"\n    attr1=\"aval1\" attr2=\"aval2\">\n    <param name=\"param1\" value=\"pval1\" />\n    <param name=\"param2\" value=\"pval2\" />\n    some content\n</object>",
            "title": "Customizing the object by passing additional arguments"
        },
        {
            "location": "/helpers/identity/",
            "text": "Identity\n\n\nThe \nIdentity\n helper allows retrieving the identity from the\n\nAuthenticationService\n.\n\n\nFor the \nIdentity\n helper to work, a \nZend\\Authentication\\AuthenticationService\n\nor \nZend\\Authentication\\AuthenticationServiceInterface\n name or alias must be\ndefined and recognized by the \nServiceManager\n.\n\n\nIdentity\n returns the identity discovered in the \nAuthenticationService\n, or\n\nnull\n if no identity is available.\n\n\nBasic Usage\n\n\n<?php\n    if ($user = $this->identity()) {\n        echo 'Logged in as ' . $this->escapeHtml($user->getUsername());\n    } else {\n        echo 'Not logged in';\n    }\n?>\n\n\n\nUsing with ServiceManager\n\n\nWhen invoked, the \nIdentity\n plugin will look for a service by the name or alias\n\nZend\\Authentication\\AuthenticationService\n in the \nServiceManager\n. You can\nprovide this service to the \nServiceManager\n in a configuration file:\n\n\n// In a configuration file...\nuse Zend\\Authentication\\AuthenticationService;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'service_manager' => [\n        'aliases' => [\n            'my_auth_service' => AuthenticationService::class,\n        ],\n        'factories' => [\n            AuthenticationService::class => InvokableFactory::class,\n        ],\n    ],\n];\n\n\n\nIf that service is not registered, the plugin will then look for a service named\n\nZend\\Authentication\\AuthenticationServiceInterface\n, and use that if found.",
            "title": "Identity"
        },
        {
            "location": "/helpers/identity/#identity",
            "text": "The  Identity  helper allows retrieving the identity from the AuthenticationService .  For the  Identity  helper to work, a  Zend\\Authentication\\AuthenticationService \nor  Zend\\Authentication\\AuthenticationServiceInterface  name or alias must be\ndefined and recognized by the  ServiceManager .  Identity  returns the identity discovered in the  AuthenticationService , or null  if no identity is available.",
            "title": "Identity"
        },
        {
            "location": "/helpers/identity/#basic-usage",
            "text": "<?php\n    if ($user = $this->identity()) {\n        echo 'Logged in as ' . $this->escapeHtml($user->getUsername());\n    } else {\n        echo 'Not logged in';\n    }\n?>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/identity/#using-with-servicemanager",
            "text": "When invoked, the  Identity  plugin will look for a service by the name or alias Zend\\Authentication\\AuthenticationService  in the  ServiceManager . You can\nprovide this service to the  ServiceManager  in a configuration file:  // In a configuration file...\nuse Zend\\Authentication\\AuthenticationService;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'service_manager' => [\n        'aliases' => [\n            'my_auth_service' => AuthenticationService::class,\n        ],\n        'factories' => [\n            AuthenticationService::class => InvokableFactory::class,\n        ],\n    ],\n];  If that service is not registered, the plugin will then look for a service named Zend\\Authentication\\AuthenticationServiceInterface , and use that if found.",
            "title": "Using with ServiceManager"
        },
        {
            "location": "/helpers/inline-script/",
            "text": "InlineScript\n\n\nThe HTML \n<script>\n element is used to either provide inline client-side\nscripting elements or link to a remote resource containing client-side scripting\ncode. The \nInlineScript\n helper allows you to manage both. It is derived from\n\nHeadScript\n, and any method of that helper is available;\nreplace the usage of \nheadScript()\n in those examples with \ninlineScript()\n.\n\n\n\n\nUse InlineScript for HTML body scripts\n\n\nInlineScript\n should be used when you wish to include scripts inline in the\nHTML \n<body>\n.  Placing scripts at the end of your document is a good practice\nfor speeding up delivery of your page, particularly when using 3rd party\nanalytics scripts.  Some JS libraries need to be included in the HTML\n\n<head>\n; use \nHeadScript\n for those scripts.\n\n\n\n\nBasic Usage\n\n\nAdd to the layout script:\n\n\n<body>\n    <!-- Content -->\n\n    <?php\n    echo $this->inlineScript()\n        ->prependFile($this->basePath('js/vendor/foundation.min.js'))\n        ->prependFile($this->basePath('js/vendor/jquery.js'));\n    ?>\n</body>\n\n\n\nOutput:\n\n\n<body>\n    <!-- Content -->\n\n    <script type=\"text/javascript\" src=\"/js/vendor/jquery.js\"></script>\n    <script type=\"text/javascript\" src=\"/js/vendor/foundation.min.js\"></script>\n</body>\n\n\n\nCapturing Scripts\n\n\nAdd in your view scripts:\n\n\n$this->inlineScript()->captureStart();\necho <<<JS\n    $('select').change(function(){\n        location.href = $(this).val();\n    });\nJS;\n$this->inlineScript()->captureEnd();\n\n\n\nOutput:\n\n\n<body>\n    <!-- Content -->\n\n    <script type=\"text/javascript\" src=\"/js/vendor/jquery.js\"></script>\n    <script type=\"text/javascript\" src=\"/js/vendor/foundation.min.js\"></script>\n    <script type=\"text/javascript\">\n        //<!--\n        $('select').change(function(){\n            location.href = $(this).val();\n        });\n        //-->\n    </script>\n</body>",
            "title": "InlineScript"
        },
        {
            "location": "/helpers/inline-script/#inlinescript",
            "text": "The HTML  <script>  element is used to either provide inline client-side\nscripting elements or link to a remote resource containing client-side scripting\ncode. The  InlineScript  helper allows you to manage both. It is derived from HeadScript , and any method of that helper is available;\nreplace the usage of  headScript()  in those examples with  inlineScript() .",
            "title": "InlineScript"
        },
        {
            "location": "/helpers/inline-script/#use-inlinescript-for-html-body-scripts",
            "text": "InlineScript  should be used when you wish to include scripts inline in the\nHTML  <body> .  Placing scripts at the end of your document is a good practice\nfor speeding up delivery of your page, particularly when using 3rd party\nanalytics scripts.  Some JS libraries need to be included in the HTML <head> ; use  HeadScript  for those scripts.",
            "title": "Use InlineScript for HTML body scripts"
        },
        {
            "location": "/helpers/inline-script/#basic-usage",
            "text": "Add to the layout script:  <body>\n    <!-- Content -->\n\n    <?php\n    echo $this->inlineScript()\n        ->prependFile($this->basePath('js/vendor/foundation.min.js'))\n        ->prependFile($this->basePath('js/vendor/jquery.js'));\n    ?>\n</body>  Output:  <body>\n    <!-- Content -->\n\n    <script type=\"text/javascript\" src=\"/js/vendor/jquery.js\"></script>\n    <script type=\"text/javascript\" src=\"/js/vendor/foundation.min.js\"></script>\n</body>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/inline-script/#capturing-scripts",
            "text": "Add in your view scripts:  $this->inlineScript()->captureStart();\necho <<<JS\n    $('select').change(function(){\n        location.href = $(this).val();\n    });\nJS;\n$this->inlineScript()->captureEnd();  Output:  <body>\n    <!-- Content -->\n\n    <script type=\"text/javascript\" src=\"/js/vendor/jquery.js\"></script>\n    <script type=\"text/javascript\" src=\"/js/vendor/foundation.min.js\"></script>\n    <script type=\"text/javascript\">\n        //<!--\n        $('select').change(function(){\n            location.href = $(this).val();\n        });\n        //-->\n    </script>\n</body>",
            "title": "Capturing Scripts"
        },
        {
            "location": "/helpers/json/",
            "text": "JSON\n\n\nWhen creating views that return JSON, it's important to also set the appropriate\nresponse header.  The JSON view helper does exactly that. In addition, by\ndefault, it disables layouts (if currently enabled), as layouts generally aren't\nused with JSON responses.\n\n\nThe JSON helper sets the following header:\n\n\nContent-Type: application/json\n\n\n\nMost XmlHttpRequest libraries look for this header when parsing responses to\ndetermine how to handle the content.\n\n\nBasic Usage\n\n\n<?= $this->json($this->data) ?>\n\n\n\n\n\nEnabling encoding using Zend\\Json\\Expr\n\n\nThe JSON helper accepts an array of options that will be passed to \nZend\\Json\\Json::encode()\n and\nused internally to encode data.\n\nZend\\Json\\Json::encode\n allows the encoding of native JSON expressions using \nZend\\Json\\Expr\n\nobjects. This option is disabled by default. To enable this option, pass a boolean \ntrue\n to the\n\nenableJsonExprFinder\n key of the options array:\n\n\n<?= $this->json($this->data, ['enableJsonExprFinder' => true]) ?>",
            "title": "Json"
        },
        {
            "location": "/helpers/json/#json",
            "text": "When creating views that return JSON, it's important to also set the appropriate\nresponse header.  The JSON view helper does exactly that. In addition, by\ndefault, it disables layouts (if currently enabled), as layouts generally aren't\nused with JSON responses.  The JSON helper sets the following header:  Content-Type: application/json  Most XmlHttpRequest libraries look for this header when parsing responses to\ndetermine how to handle the content.",
            "title": "JSON"
        },
        {
            "location": "/helpers/json/#basic-usage",
            "text": "<?= $this->json($this->data) ?>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/json/#enabling-encoding-using-zendjsonexpr",
            "text": "The JSON helper accepts an array of options that will be passed to  Zend\\Json\\Json::encode()  and\nused internally to encode data. Zend\\Json\\Json::encode  allows the encoding of native JSON expressions using  Zend\\Json\\Expr \nobjects. This option is disabled by default. To enable this option, pass a boolean  true  to the enableJsonExprFinder  key of the options array:  <?= $this->json($this->data, ['enableJsonExprFinder' => true]) ?>",
            "title": "Enabling encoding using Zend\\Json\\Expr"
        },
        {
            "location": "/helpers/layout/",
            "text": "Layout\n\n\nThe \nLayout\n helper is used to get and set the template for the layout or to \nretrieving the root view model.\n\n\nBasic Usage\n\n\nChange the Layout Template\n\n\nIf you're running a zend-mvc application then the layout template is set in the\nconfiguration for the \nViewManager\n.\n\n\nTo change the layout template within a view script, call:\n\n\n$this->layout('layout/backend');\n\n\n\nOr use the \nsetTemplate\n method:\n\n\n$this->layout()->setTemplate('layout/backend');\n\n\n\nSet View Variable on Layout Model\n\n\nThe \nLayout\n helper can also retrieve the view model for the layout (root): \n\n\n/** @var \\Zend\\View\\Model\\ViewModel $rootViewModel */\n$rootViewModel = $this->layout();\n\n\n\nThis offers the possibility to set variables for the layout script.\n\n\nSet a Single Variable\n\n\n$this->layout()->setVariable('infoText', 'Some text for later');\n\n\n\nUse in your layout script:\n\n\nif (isset($infoText)) {\n    echo $infoText;\n}\n\n\n\nSet a Set of Variables\n\n\n$this->layout()->setVariables([\n    'headerText' => '\u2026',\n    'footerText' => '\u2026',\n]);\n\n\n\nMore informations related to view models can be found in the\n\nquick start\n.",
            "title": "Layout"
        },
        {
            "location": "/helpers/layout/#layout",
            "text": "The  Layout  helper is used to get and set the template for the layout or to \nretrieving the root view model.",
            "title": "Layout"
        },
        {
            "location": "/helpers/layout/#basic-usage",
            "text": "",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/layout/#change-the-layout-template",
            "text": "If you're running a zend-mvc application then the layout template is set in the\nconfiguration for the  ViewManager .  To change the layout template within a view script, call:  $this->layout('layout/backend');  Or use the  setTemplate  method:  $this->layout()->setTemplate('layout/backend');",
            "title": "Change the Layout Template"
        },
        {
            "location": "/helpers/layout/#set-view-variable-on-layout-model",
            "text": "The  Layout  helper can also retrieve the view model for the layout (root):   /** @var \\Zend\\View\\Model\\ViewModel $rootViewModel */\n$rootViewModel = $this->layout();  This offers the possibility to set variables for the layout script.",
            "title": "Set View Variable on Layout Model"
        },
        {
            "location": "/helpers/layout/#set-a-single-variable",
            "text": "$this->layout()->setVariable('infoText', 'Some text for later');  Use in your layout script:  if (isset($infoText)) {\n    echo $infoText;\n}",
            "title": "Set a Single Variable"
        },
        {
            "location": "/helpers/layout/#set-a-set-of-variables",
            "text": "$this->layout()->setVariables([\n    'headerText' => '\u2026',\n    'footerText' => '\u2026',\n]);  More informations related to view models can be found in the quick start .",
            "title": "Set a Set of Variables"
        },
        {
            "location": "/helpers/partial/",
            "text": "Partial\n\n\nThe \nPartial\n view helper is used to render a specified template within its own\nvariable scope. The primary use is for reusable template fragments with which\nyou do not need to worry about variable name clashes.\n\n\nA sibling to the \nPartial\n, the \nPartialLoop\n view helper allows you to pass\niterable data, and render a partial for each item.\n\n\n\n\nPartialLoop Counter\n\n\nThe \nPartialLoop\n view helper gives access to the current position of the\narray within the view script via \n$this->partialLoop()->getPartialCounter()\n.\nThis provides a way to have alternating colors on table rows, for example.\n\n\n\n\nBasic Usage\n\n\nBasic usage of partials is to render a template fragment in its own view scope.\nConsider the following partial script:\n\n\n<?php // partial.phtml ?>\n<ul>\n    <li>From: <?= $this->escapeHtml($this->from) ?></li>\n    <li>Subject: <?= $this->escapeHtml($this->subject) ?></li>\n</ul>\n\n\n\nYou would then call it from your view script using the following:\n\n\n<?= $this->partial('partial.phtml', [\n    'from' => 'Team Framework',\n    'subject' => 'view partials',\n]); ?>\n\n\n\nWhich would then render:\n\n\n<ul>\n    <li>From: Team Framework</li>\n    <li>Subject: view partials</li>\n</ul>\n\n\n\n\n\nWhat is a model?\n\n\nA model used with the \nPartial\n view helper can be one of the following:\n\n\n\n\narray\n: If an array is passed, it should be associative, as its key/value\n  pairs are assigned to > the view with keys as view variables.\n\n\nObject implementing \ntoArray(\n) method\n. If an object is passed an has a\n  \ntoArray()\n method, the results of \ntoArray()\n will be assigned to the view\n  object as view variables.\n\n\nStandard object\n. Any other object will assign the results of\n  \nget_object_vars()\n (essentially all public properties of the object) to the\n  view object.\n\n\n\n\nIf your model is an object, you may want to have it passed \nas an object\n to\nthe partial script, instead of serializing it to an array of variables. You\ncan do this by setting the \nobjectKey\n property of the appropriate helper:\n\n\n// Tell partial to pass objects as 'model' variable\n$view->partial()->setObjectKey('model');\n\n// Tell partial to pass objects from partialLoop as 'model' variable\n// in final partial view script:\n$view->partialLoop()->setObjectKey('model');\n\n\n\nThis technique is particularly useful when passing\n\nZend\\Db\\ResultSet\\ResultSet\ns to \npartialLoop()\n, as you then have full\naccess to your row objects within the view scripts, allowing you to call\nmethods on them (such as retrieving values from parent or dependent rows).\n\n\n\n\nUsing PartialLoop to Render Iterable Models\n\n\nTypically, you'll want to use partials in a loop, to render the same content\nfragment many times; this way you can put large blocks of repeated content or\ncomplex display logic into a single location. However this has a performance\nimpact, as the partial helper needs to be invoked once for each iteration.\n\n\nThe \nPartialLoop\n view helper helps solve this issue. It allows you to pass an\niterable item (array or object implementing \nIterator\n) as the model. It then\niterates over this, passing, the items to the partial script as the model. Items\nin the iterator may be any model the \nPartial\n view helper allows.\n\n\nLet's assume the following partial view script:\n\n\n<?php // partialLoop.phtml ?>\n    <dt><?= $this->key ?></dt>\n    <dd><?= $this->value ?></dd>\n\n\n\nAnd the following \"model\":\n\n\n$model = [\n    ['key' => 'Mammal', 'value' => 'Camel'],\n    ['key' => 'Bird', 'value' => 'Penguin'],\n    ['key' => 'Reptile', 'value' => 'Asp'],\n    ['key' => 'Fish', 'value' => 'Flounder'],\n];\n\n\n\nIn your view script, you could then invoke the \nPartialLoop\n helper:\n\n\n<dl>\n<?= $this->partialLoop('partialLoop.phtml', $model) ?>\n</dl>\n\n\n\nResulting in the following:\n\n\n<dl>\n    <dt>Mammal</dt>\n    <dd>Camel</dd>\n\n    <dt>Bird</dt>\n    <dd>Penguin</dd>\n\n    <dt>Reptile</dt>\n    <dd>Asp</dd>\n\n    <dt>Fish</dt>\n    <dd>Flounder</dd>\n</dl>",
            "title": "Partial"
        },
        {
            "location": "/helpers/partial/#partial",
            "text": "The  Partial  view helper is used to render a specified template within its own\nvariable scope. The primary use is for reusable template fragments with which\nyou do not need to worry about variable name clashes.  A sibling to the  Partial , the  PartialLoop  view helper allows you to pass\niterable data, and render a partial for each item.",
            "title": "Partial"
        },
        {
            "location": "/helpers/partial/#partialloop-counter",
            "text": "The  PartialLoop  view helper gives access to the current position of the\narray within the view script via  $this->partialLoop()->getPartialCounter() .\nThis provides a way to have alternating colors on table rows, for example.",
            "title": "PartialLoop Counter"
        },
        {
            "location": "/helpers/partial/#basic-usage",
            "text": "Basic usage of partials is to render a template fragment in its own view scope.\nConsider the following partial script:  <?php // partial.phtml ?>\n<ul>\n    <li>From: <?= $this->escapeHtml($this->from) ?></li>\n    <li>Subject: <?= $this->escapeHtml($this->subject) ?></li>\n</ul>  You would then call it from your view script using the following:  <?= $this->partial('partial.phtml', [\n    'from' => 'Team Framework',\n    'subject' => 'view partials',\n]); ?>  Which would then render:  <ul>\n    <li>From: Team Framework</li>\n    <li>Subject: view partials</li>\n</ul>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/partial/#what-is-a-model",
            "text": "A model used with the  Partial  view helper can be one of the following:   array : If an array is passed, it should be associative, as its key/value\n  pairs are assigned to > the view with keys as view variables.  Object implementing  toArray( ) method . If an object is passed an has a\n   toArray()  method, the results of  toArray()  will be assigned to the view\n  object as view variables.  Standard object . Any other object will assign the results of\n   get_object_vars()  (essentially all public properties of the object) to the\n  view object.   If your model is an object, you may want to have it passed  as an object  to\nthe partial script, instead of serializing it to an array of variables. You\ncan do this by setting the  objectKey  property of the appropriate helper:  // Tell partial to pass objects as 'model' variable\n$view->partial()->setObjectKey('model');\n\n// Tell partial to pass objects from partialLoop as 'model' variable\n// in final partial view script:\n$view->partialLoop()->setObjectKey('model');  This technique is particularly useful when passing Zend\\Db\\ResultSet\\ResultSet s to  partialLoop() , as you then have full\naccess to your row objects within the view scripts, allowing you to call\nmethods on them (such as retrieving values from parent or dependent rows).",
            "title": "What is a model?"
        },
        {
            "location": "/helpers/partial/#using-partialloop-to-render-iterable-models",
            "text": "Typically, you'll want to use partials in a loop, to render the same content\nfragment many times; this way you can put large blocks of repeated content or\ncomplex display logic into a single location. However this has a performance\nimpact, as the partial helper needs to be invoked once for each iteration.  The  PartialLoop  view helper helps solve this issue. It allows you to pass an\niterable item (array or object implementing  Iterator ) as the model. It then\niterates over this, passing, the items to the partial script as the model. Items\nin the iterator may be any model the  Partial  view helper allows.  Let's assume the following partial view script:  <?php // partialLoop.phtml ?>\n    <dt><?= $this->key ?></dt>\n    <dd><?= $this->value ?></dd>  And the following \"model\":  $model = [\n    ['key' => 'Mammal', 'value' => 'Camel'],\n    ['key' => 'Bird', 'value' => 'Penguin'],\n    ['key' => 'Reptile', 'value' => 'Asp'],\n    ['key' => 'Fish', 'value' => 'Flounder'],\n];  In your view script, you could then invoke the  PartialLoop  helper:  <dl>\n<?= $this->partialLoop('partialLoop.phtml', $model) ?>\n</dl>  Resulting in the following:  <dl>\n    <dt>Mammal</dt>\n    <dd>Camel</dd>\n\n    <dt>Bird</dt>\n    <dd>Penguin</dd>\n\n    <dt>Reptile</dt>\n    <dd>Asp</dd>\n\n    <dt>Fish</dt>\n    <dd>Flounder</dd>\n</dl>",
            "title": "Using PartialLoop to Render Iterable Models"
        },
        {
            "location": "/helpers/placeholder/",
            "text": "Placeholder\n\n\nThe \nPlaceholder\n view helper is used to persist content between view scripts\nand view instances. It also offers some useful features such as aggregating\ncontent, capturing view script content for later use, and adding pre- and\npost-text to content (and custom separators for aggregated content).\n\n\nBasic Usage\n\n\nBasic usage of placeholders is to persist view data. Each invocation of the\n\nPlaceholder\n helper expects a placeholder name; the helper then returns a\nplaceholder container object that you can either manipulate or echo.\n\n\n<?php $this->placeholder('foo')->set(\"Some text for later\") ?>\n\n<?= $this->placeholder('foo'); ?>\n\n\n\nResults in:\n\n\nSome text for later\n\n\n\nAggregate Content\n\n\nAggregating content via placeholders can be useful at times as well. For\ninstance, your view script may have a variable array from which you wish to\nretrieve messages to display later; a later view script can then determine how\nthose will be rendered.\n\n\nThe \nPlaceholder\n view helper uses containers that extend \nArrayObject\n,\nproviding a rich feature set for manipulating arrays. In addition, it offers a\nvariety of methods for formatting the content stored in the container:\n\n\n\n\nsetPrefix($prefix)\n sets text with which to prefix the content. Use\n  \ngetPrefix()\n at any time to determine what the current setting is.\n\n\nsetPostfix($prefix)\n sets text with which to append the content. Use\n  \ngetPostfix()\n at any time to determine what the current setting is.\n\n\nsetSeparator($prefix)\n sets text with which to separate aggregated content.\n  Use \ngetSeparator()\n at any time to determine what the current setting is.\n\n\nsetIndent($prefix)\n can be used to set an indentation value for content. If\n  an integer is passed, that number of spaces will be used; if a string is\n  passed, the string will be used. Use \ngetIndent()\n at any time to determine\n  what the current setting is.\n\n\n\n\n<!-- first view script -->\n<?php $this->placeholder('foo')->exchangeArray($this->data) ?>\n\n\n\n<!-- later view script -->\n<?php\n$this->placeholder('foo')\n    ->setPrefix(\"<ul>\\n    <li>\")\n    ->setSeparator(\"</li><li>\\n\")\n    ->setIndent(4)\n    ->setPostfix(\"</li></ul>\\n\");\n?>\n\n<?= $this->placeholder('foo') ?>\n\n\n\nThe above results in an unordered list with pretty indentation.\n\n\nBecause the \nPlaceholder\n container objects extend \nArrayObject\n, you can also\nassign content to a specific key in the container easily, instead of simply\npushing it into the container. Keys may be accessed either as object properties\nor as array keys.\n\n\n<?php $this->placeholder('foo')->bar = $this->data ?>\n<?= $this->placeholder('foo')->bar ?>\n\n<?php\n$foo = $this->placeholder('foo');\necho $foo['bar'];\n\n\n\nCapture Content\n\n\nOccasionally you may have content for a placeholder in a view script that is\neasiest to template; the \nPlaceholder\n view helper allows you to capture\narbitrary content for later rendering using the following API.\n\n\n\n\ncaptureStart($type, $key)\n begins capturing content.\n\n\n$type\n should be one of the \nPlaceholder\n constants \nAPPEND\n or \nSET\n. If\n    \nAPPEND\n, captured content is appended to the list of current content in the\n    placeholder; if \nSET\n, captured content is used as the sole value of the\n    placeholder (potentially replacing any previous content). By default,\n    \n$type\n is \nAPPEND\n.\n\n\n$key\n can be used to specify a specific key in the placeholder container to\n    which you want content captured.\n\n\ncaptureStart()\n locks capturing until \ncaptureEnd()\n is called; you cannot\n    nest capturing with the same placeholder container. Doing so will raise an\n    exception.\n\n\ncaptureEnd()\n stops capturing content, and places it in the container object\n  according to how \ncaptureStart()\n was called.\n\n\n\n\nAs an example:\n\n\n<!-- Default capture: append -->\n<?php $this->placeholder('foo')->captureStart();\nforeach ($this->data as $datum): ?>\n<div class=\"foo\">\n    <h2><?= $datum->title ?></h2>\n    <p><?= $datum->content ?></p>\n</div>\n<?php endforeach; ?>\n<?php $this->placeholder('foo')->captureEnd() ?>\n\n<?= $this->placeholder('foo') ?>\n\n\n\nAlternately, capture to a key:\n\n\n<!-- Capture to key -->\n<?php $this->placeholder('foo')->captureStart('SET', 'data');\nforeach ($this->data as $datum): ?>\n<div class=\"foo\">\n    <h2><?= $datum->title ?></h2>\n    <p><?= $datum->content ?></p>\n</div>\n <?php endforeach; ?>\n<?php $this->placeholder('foo')->captureEnd() ?>\n\n<?= $this->placeholder('foo')->data ?>\n\n\n\nClearing Content\n\n\nIn certain situations it is desirable to remove or clear containers and\naggregated content. The placeholder view helper provides two methods to either\ndelete a specific container or clear all containers at once:\n\n\nDelete a single container\n\n\n$this->plugin('placeholder')->deleteContainer('myNamedContainer');\n\n\n\nClear all containers\n\n\n$this->plugin('placeholder')->clearContainers();\n\n\n\nConcrete Implementations\n\n\nzend-view ships with a number of \"concrete\" placeholder implementations. These\nare for commonly used placeholders: doctype, page title, and various \n<head>\n\nelements. In all cases, calling the placeholder with no arguments returns the\nelement itself.\n\n\nDocumentation for each element is covered separately, as linked below:\n\n\n\n\nDoctype\n\n\nHeadLink\n\n\nHeadMeta\n\n\nHeadScript\n\n\nHeadStyle\n\n\nHeadTitle\n\n\nInlineScript",
            "title": "Placeholder"
        },
        {
            "location": "/helpers/placeholder/#placeholder",
            "text": "The  Placeholder  view helper is used to persist content between view scripts\nand view instances. It also offers some useful features such as aggregating\ncontent, capturing view script content for later use, and adding pre- and\npost-text to content (and custom separators for aggregated content).",
            "title": "Placeholder"
        },
        {
            "location": "/helpers/placeholder/#basic-usage",
            "text": "Basic usage of placeholders is to persist view data. Each invocation of the Placeholder  helper expects a placeholder name; the helper then returns a\nplaceholder container object that you can either manipulate or echo.  <?php $this->placeholder('foo')->set(\"Some text for later\") ?>\n\n<?= $this->placeholder('foo'); ?>  Results in:  Some text for later",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/placeholder/#aggregate-content",
            "text": "Aggregating content via placeholders can be useful at times as well. For\ninstance, your view script may have a variable array from which you wish to\nretrieve messages to display later; a later view script can then determine how\nthose will be rendered.  The  Placeholder  view helper uses containers that extend  ArrayObject ,\nproviding a rich feature set for manipulating arrays. In addition, it offers a\nvariety of methods for formatting the content stored in the container:   setPrefix($prefix)  sets text with which to prefix the content. Use\n   getPrefix()  at any time to determine what the current setting is.  setPostfix($prefix)  sets text with which to append the content. Use\n   getPostfix()  at any time to determine what the current setting is.  setSeparator($prefix)  sets text with which to separate aggregated content.\n  Use  getSeparator()  at any time to determine what the current setting is.  setIndent($prefix)  can be used to set an indentation value for content. If\n  an integer is passed, that number of spaces will be used; if a string is\n  passed, the string will be used. Use  getIndent()  at any time to determine\n  what the current setting is.   <!-- first view script -->\n<?php $this->placeholder('foo')->exchangeArray($this->data) ?>  <!-- later view script -->\n<?php\n$this->placeholder('foo')\n    ->setPrefix(\"<ul>\\n    <li>\")\n    ->setSeparator(\"</li><li>\\n\")\n    ->setIndent(4)\n    ->setPostfix(\"</li></ul>\\n\");\n?>\n\n<?= $this->placeholder('foo') ?>  The above results in an unordered list with pretty indentation.  Because the  Placeholder  container objects extend  ArrayObject , you can also\nassign content to a specific key in the container easily, instead of simply\npushing it into the container. Keys may be accessed either as object properties\nor as array keys.  <?php $this->placeholder('foo')->bar = $this->data ?>\n<?= $this->placeholder('foo')->bar ?>\n\n<?php\n$foo = $this->placeholder('foo');\necho $foo['bar'];",
            "title": "Aggregate Content"
        },
        {
            "location": "/helpers/placeholder/#capture-content",
            "text": "Occasionally you may have content for a placeholder in a view script that is\neasiest to template; the  Placeholder  view helper allows you to capture\narbitrary content for later rendering using the following API.   captureStart($type, $key)  begins capturing content.  $type  should be one of the  Placeholder  constants  APPEND  or  SET . If\n     APPEND , captured content is appended to the list of current content in the\n    placeholder; if  SET , captured content is used as the sole value of the\n    placeholder (potentially replacing any previous content). By default,\n     $type  is  APPEND .  $key  can be used to specify a specific key in the placeholder container to\n    which you want content captured.  captureStart()  locks capturing until  captureEnd()  is called; you cannot\n    nest capturing with the same placeholder container. Doing so will raise an\n    exception.  captureEnd()  stops capturing content, and places it in the container object\n  according to how  captureStart()  was called.   As an example:  <!-- Default capture: append -->\n<?php $this->placeholder('foo')->captureStart();\nforeach ($this->data as $datum): ?>\n<div class=\"foo\">\n    <h2><?= $datum->title ?></h2>\n    <p><?= $datum->content ?></p>\n</div>\n<?php endforeach; ?>\n<?php $this->placeholder('foo')->captureEnd() ?>\n\n<?= $this->placeholder('foo') ?>  Alternately, capture to a key:  <!-- Capture to key -->\n<?php $this->placeholder('foo')->captureStart('SET', 'data');\nforeach ($this->data as $datum): ?>\n<div class=\"foo\">\n    <h2><?= $datum->title ?></h2>\n    <p><?= $datum->content ?></p>\n</div>\n <?php endforeach; ?>\n<?php $this->placeholder('foo')->captureEnd() ?>\n\n<?= $this->placeholder('foo')->data ?>",
            "title": "Capture Content"
        },
        {
            "location": "/helpers/placeholder/#clearing-content",
            "text": "In certain situations it is desirable to remove or clear containers and\naggregated content. The placeholder view helper provides two methods to either\ndelete a specific container or clear all containers at once:",
            "title": "Clearing Content"
        },
        {
            "location": "/helpers/placeholder/#delete-a-single-container",
            "text": "$this->plugin('placeholder')->deleteContainer('myNamedContainer');",
            "title": "Delete a single container"
        },
        {
            "location": "/helpers/placeholder/#clear-all-containers",
            "text": "$this->plugin('placeholder')->clearContainers();",
            "title": "Clear all containers"
        },
        {
            "location": "/helpers/placeholder/#concrete-implementations",
            "text": "zend-view ships with a number of \"concrete\" placeholder implementations. These\nare for commonly used placeholders: doctype, page title, and various  <head> \nelements. In all cases, calling the placeholder with no arguments returns the\nelement itself.  Documentation for each element is covered separately, as linked below:   Doctype  HeadLink  HeadMeta  HeadScript  HeadStyle  HeadTitle  InlineScript",
            "title": "Concrete Implementations"
        },
        {
            "location": "/helpers/url/",
            "text": "URL\n\n\nThe URL view helper is used to create a string representation of the routes that\nyou define within your application. The syntax for the view helper is\n\n$this->url($name, $params, $options, $reuseMatchedParameters)\n, using the\nfollowing definitions for the helper arguments:\n\n\n\n\n$name\n: The name of the route you want to output.\n\n\n$params\n: An array of parameters that is defined within the respective route\n  configuration.\n\n\n$options\n: An array of options that will be used to create the URL.\n\n\n$reuseMatchedParams\n: A flag indicating if the currently matched route\n  parameters should be used when generating the new URL.\n\n\n\n\nLet's take a look at how this view helper is used in real-world applications.\n\n\nBasic Usage\n\n\nThe following example shows a simple configuration for a news module. The route\nis called \nnews\n and it has two \noptional\n parameters called \naction\n and\n\nid\n.\n\n\n// In a configuration array (e.g. returned by some module's module.config.php)\n'router' => [\n    'routes' => [\n        'news' => [\n            'type'    => 'segment',\n            'options' => [\n                'route'       => '/news[/:action][/:id]',\n                'constraints' => [\n                    'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                ],\n                'defaults' => [\n                    'controller' => 'news',\n                    'action'     => 'index',\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nFirst, let's use the view helper to create the output for the URL \n/news\n without any of the\noptional parameters being used:\n\n\n<a href=\"<?= $this->url('news'); ?>\">News Index</a>\n\n\n\nThis will render the output:\n\n\n<a href=\"/news\">News Index</a>\n\n\n\nNow let's assume we want to get a link to display the detail page of a single\nnews entry. For this task, the optional parameters \naction\n and \nid\n need to\nhave values assigned. This is how you do that:\n\n\n<a href=\"<?= $this->url('news', ['action' => 'details', 'id' => 42]); ?>\">\n    Details of News #42\n</a>\n\n\n\nThis will render the output:\n\n\n<a href=\"/news/details/42\">News Index</a>\n\n\n\nQuery String Arguments\n\n\nMost SEO experts agree that pagination parameters should not be part of the URL\npath; for example, the following URL would be considered a bad practice:\n\n/news/archive/page/13\n. Pagination is more correctly accomplished using a query\nstring arguments, such as \n/news/archive?page=13\n. To achieve this, you'll need\nto make use of the \n$options\n argument from the view helper.\n\n\nWe will use the same route configuration as defined above:\n\n\n// In a configuration array (e.g. returned by some module's module.config.php)\n'router' => [\n    'routes' => [\n        'news' => [\n            'type'    => 'segment',\n            'options' => [\n                'route'       => '/news[/:action][/:id]',\n                'constraints' => [\n                    'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                ],\n                'defaults' => [\n                    'controller' => 'news',\n                    'action'     => 'index',\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nTo generate query string arguments from the view helper, you need to assign them\nas the third argument using the \nquery\n key like this:\n\n\n<?php\n$url = $this->url(\n    'news',\n    ['action' => 'archive'],\n    [\n        'query' => [\n            'page' => 13,\n        ],\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">News Archive Page #13</a>\n\n\n\nThe above code sample would output:\n\n\n<a href=\"/news/archive?page=13\">News Archive Page #13</a>\n\n\n\nFragments\n\n\nAnother possible entry within the \n$options\n array is the assignment of URL\nfragments (typically used to link to in-page anchors), denoted with using the\n\nfragment\n key. Let's assume we want to enter a link for users to directly jump\nto the comment section of a details page:\n\n\n<?php\n$url = $this->url(\n    'news',\n    ['action' => 'details', 'id' => 42],\n    [\n        'fragment' => 'comments',\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">Comment Section of News #42</a>\n\n\n\nThe above code sample would output:\n\n\n<a href=\"/news/details/42#comments\">Comment Section of News #42</a>\n\n\n\nYou can use \nfragment\n and \nquery\n options at the same time!\n\n\n<?php\n$url = $this->url(\n    'news',\n    ['action' => 'details', 'id' => 42],\n    [\n        'query' => [\n            'commentPage' => 3,\n        ],\n        'fragment' => 'comments',\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">Comment Section of News #42</a>\n\n\n\nThe above code sample would output:\n\n\n<a href=\"/news/details/42?commentPage=3#comments\">Comment Section of News #42</a>\n\n\n\nFully Qualified Domain Name\n\n\nAnother possible entry within the \n$options\n array is to output a fully\nqualified domain name (absolute URL), denoted using the \nforce_canonical\n key:\n\n\n<?php\n$url = $this->url(\n    'news',\n    [],\n    [\n        'force_canonical' => true,\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">News Index</a>\n\n\n\nThe above code sample would output:\n\n\n<a href=\"http://www.example.com/news\">News Index</a>\n\n\n\nReusing Matched Parameters\n\n\nWhen you're on a route that has many parameters, often times it makes sense to\nreuse currently matched parameters instead of assigning them explicitly. In this\ncase, the argument \n$reuseMatchedParams\n will come in handy.\n\n\nAs an example, we will imagine being on a detail page for our \nnews\n route. We\nwant to display links to the \nedit\n and \ndelete\n actions without having to\nassign the ID again:\n\n\n// Currently url /news/details/777\n\n<a href=\"<?= $this->url('news', ['action' => 'edit'], null, true); ?>\">Edit Me</a>\n<a href=\"<?= $this->url('news', ['action' => 'delete'], null, true); ?>\">Delete Me</a>\n\n\n\nNotice the \ntrue\n argument in the fourth position. This tells the view helper to\nuse the matched \nid\n (\n777\n) when creating the new URL:\n\n\n<a href=\"/news/edit/777\">Edit Me</a>\n<a href=\"/news/delete/777\">Edit Me</a>\n\n\n\nShorthand\n\n\nDue to the fact that reusing parameters is a use case that can happen when no\nroute options are set, the third argument for the URL view helper will be\nchecked against its type; when a \nboolean\n is passed, the helper uses it to set\nthe value of the \n$reuseMatchedParams\n flag:\n\n\n$this->url('news', ['action' => 'archive'], null, true);\n// is equal to\n$this->url('news', ['action' => 'archive'], true);",
            "title": "Url"
        },
        {
            "location": "/helpers/url/#url",
            "text": "The URL view helper is used to create a string representation of the routes that\nyou define within your application. The syntax for the view helper is $this->url($name, $params, $options, $reuseMatchedParameters) , using the\nfollowing definitions for the helper arguments:   $name : The name of the route you want to output.  $params : An array of parameters that is defined within the respective route\n  configuration.  $options : An array of options that will be used to create the URL.  $reuseMatchedParams : A flag indicating if the currently matched route\n  parameters should be used when generating the new URL.   Let's take a look at how this view helper is used in real-world applications.",
            "title": "URL"
        },
        {
            "location": "/helpers/url/#basic-usage",
            "text": "The following example shows a simple configuration for a news module. The route\nis called  news  and it has two  optional  parameters called  action  and id .  // In a configuration array (e.g. returned by some module's module.config.php)\n'router' => [\n    'routes' => [\n        'news' => [\n            'type'    => 'segment',\n            'options' => [\n                'route'       => '/news[/:action][/:id]',\n                'constraints' => [\n                    'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                ],\n                'defaults' => [\n                    'controller' => 'news',\n                    'action'     => 'index',\n                ],\n            ],\n        ],\n    ],\n],  First, let's use the view helper to create the output for the URL  /news  without any of the\noptional parameters being used:  <a href=\"<?= $this->url('news'); ?>\">News Index</a>  This will render the output:  <a href=\"/news\">News Index</a>  Now let's assume we want to get a link to display the detail page of a single\nnews entry. For this task, the optional parameters  action  and  id  need to\nhave values assigned. This is how you do that:  <a href=\"<?= $this->url('news', ['action' => 'details', 'id' => 42]); ?>\">\n    Details of News #42\n</a>  This will render the output:  <a href=\"/news/details/42\">News Index</a>",
            "title": "Basic Usage"
        },
        {
            "location": "/helpers/url/#query-string-arguments",
            "text": "Most SEO experts agree that pagination parameters should not be part of the URL\npath; for example, the following URL would be considered a bad practice: /news/archive/page/13 . Pagination is more correctly accomplished using a query\nstring arguments, such as  /news/archive?page=13 . To achieve this, you'll need\nto make use of the  $options  argument from the view helper.  We will use the same route configuration as defined above:  // In a configuration array (e.g. returned by some module's module.config.php)\n'router' => [\n    'routes' => [\n        'news' => [\n            'type'    => 'segment',\n            'options' => [\n                'route'       => '/news[/:action][/:id]',\n                'constraints' => [\n                    'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                ],\n                'defaults' => [\n                    'controller' => 'news',\n                    'action'     => 'index',\n                ],\n            ],\n        ],\n    ],\n],  To generate query string arguments from the view helper, you need to assign them\nas the third argument using the  query  key like this:  <?php\n$url = $this->url(\n    'news',\n    ['action' => 'archive'],\n    [\n        'query' => [\n            'page' => 13,\n        ],\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">News Archive Page #13</a>  The above code sample would output:  <a href=\"/news/archive?page=13\">News Archive Page #13</a>",
            "title": "Query String Arguments"
        },
        {
            "location": "/helpers/url/#fragments",
            "text": "Another possible entry within the  $options  array is the assignment of URL\nfragments (typically used to link to in-page anchors), denoted with using the fragment  key. Let's assume we want to enter a link for users to directly jump\nto the comment section of a details page:  <?php\n$url = $this->url(\n    'news',\n    ['action' => 'details', 'id' => 42],\n    [\n        'fragment' => 'comments',\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">Comment Section of News #42</a>  The above code sample would output:  <a href=\"/news/details/42#comments\">Comment Section of News #42</a>  You can use  fragment  and  query  options at the same time!  <?php\n$url = $this->url(\n    'news',\n    ['action' => 'details', 'id' => 42],\n    [\n        'query' => [\n            'commentPage' => 3,\n        ],\n        'fragment' => 'comments',\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">Comment Section of News #42</a>  The above code sample would output:  <a href=\"/news/details/42?commentPage=3#comments\">Comment Section of News #42</a>",
            "title": "Fragments"
        },
        {
            "location": "/helpers/url/#fully-qualified-domain-name",
            "text": "Another possible entry within the  $options  array is to output a fully\nqualified domain name (absolute URL), denoted using the  force_canonical  key:  <?php\n$url = $this->url(\n    'news',\n    [],\n    [\n        'force_canonical' => true,\n    ]\n);\n?>\n<a href=\"<?= $url; ?>\">News Index</a>  The above code sample would output:  <a href=\"http://www.example.com/news\">News Index</a>",
            "title": "Fully Qualified Domain Name"
        },
        {
            "location": "/helpers/url/#reusing-matched-parameters",
            "text": "When you're on a route that has many parameters, often times it makes sense to\nreuse currently matched parameters instead of assigning them explicitly. In this\ncase, the argument  $reuseMatchedParams  will come in handy.  As an example, we will imagine being on a detail page for our  news  route. We\nwant to display links to the  edit  and  delete  actions without having to\nassign the ID again:  // Currently url /news/details/777\n\n<a href=\"<?= $this->url('news', ['action' => 'edit'], null, true); ?>\">Edit Me</a>\n<a href=\"<?= $this->url('news', ['action' => 'delete'], null, true); ?>\">Delete Me</a>  Notice the  true  argument in the fourth position. This tells the view helper to\nuse the matched  id  ( 777 ) when creating the new URL:  <a href=\"/news/edit/777\">Edit Me</a>\n<a href=\"/news/delete/777\">Edit Me</a>",
            "title": "Reusing Matched Parameters"
        },
        {
            "location": "/helpers/url/#shorthand",
            "text": "Due to the fact that reusing parameters is a use case that can happen when no\nroute options are set, the third argument for the URL view helper will be\nchecked against its type; when a  boolean  is passed, the helper uses it to set\nthe value of the  $reuseMatchedParams  flag:  $this->url('news', ['action' => 'archive'], null, true);\n// is equal to\n$this->url('news', ['action' => 'archive'], true);",
            "title": "Shorthand"
        },
        {
            "location": "/helpers/advanced-usage/",
            "text": "Advanced usage of helpers\n\n\nRegistering Helpers\n\n\nZend\\View\\Renderer\\PhpRenderer\n composes a \nplugin manager\n for managing\nhelpers, specifically an instance of \nZend\\View\\HelperPluginManager\n, which\nextends \nZend\\ServiceManager\\AbstractPluginManager\n, which is itself an\nextension of \nZend\\ServiceManager\\ServiceManager\n.  \nHelperPluginManager\n is a\nspecialized service manager, so you can register a helper/plugin like any other\nservice (see the \nService Manager documentation\n\nfor more information).\n\n\nProgrammatically, this is done as follows:\n\n\nuse MyModule\\View\\Helper\\LowerCase;\n\n// $view is an instance of PhpRenderer\n$pluginManager = $view->getHelperPluginManager();\n\n// Register an alias:\n$pluginManager->setAlias('lowercase', LowerCase::class);\n\n// Register a factory:\n$pluginManager->setFactory(LowerCase::class, function () {\n   $lowercaseHelper = new LowerCase();\n\n   // ...do some configuration or dependency injection...\n\n   return $lowercaseHelper;\n});\n\n\n\nWithin an MVC application, you will typically pass a map of plugins to the class\nvia your configuration.\n\n\nuse MyModule\\View\\Helper;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\n// From within a configuration file\nreturn [\n   'view_helpers' => [\n        'aliases' => [\n            'lowercase' => Helper\\LowerCase::class,\n            'uppercase' => Helper\\UpperCase::class,\n        ],\n        'factories' => [\n            LowerCase::class => InvokableFactory::class,\n            UpperCase::class => InvokableFactory::class,\n        ],\n    ],\n];\n\n\n\nIf your module class implements \nZend\\ModuleManager\\Feature\\ViewHelperProviderInterface\n,\nor just the method \ngetViewHelperConfig()\n, you could also do the following\n(it's the same as the previous example).\n\n\nnamespace MyModule;\n\nclass Module\n{\n    public function getViewHelperConfig()\n    {\n        return [\n            'aliases' => [\n                'lowercase' => Helper\\LowerCase::class,\n                'uppercase' => Helper\\UpperCase::class,\n            ],\n            'factories' => [\n                LowerCase::class => InvokableFactory::class,\n                UpperCase::class => InvokableFactory::class,\n            ],\n        ];\n    }\n}\n\n\n\nThe two latter examples can be done in each module that needs to register\nhelpers with the \nPhpRenderer\n; however, be aware that another module can\nregister helpers with the same name, so order of modules can impact which helper\nclass will actually be registered!\n\n\nWriting Custom Helpers\n\n\nWriting custom helpers is easy. We recommend extending\n\nZend\\View\\Helper\\AbstractHelper\n, but at the minimum, you need only implement\nthe \nZend\\View\\Helper\\HelperInterface\n interface:\n\n\nnamespace Zend\\View\\Helper;\n\nuse Zend\\View\\Renderer\\RendererInterface as Renderer;\n\ninterface HelperInterface\n{\n    /**\n     * Set the View object\n     *\n     * @param  Renderer $view\n     * @return HelperInterface\n     */\n    public function setView(Renderer $view);\n\n    /**\n     * Get the View object\n     *\n     * @return Renderer\n     */\n    public function getView();\n}\n\n\n\nIf you want your helper to be capable of being invoked as if it were a method call of the\n\nPhpRenderer\n, you should also implement an \n__invoke()\n method within your helper.\n\n\nAs previously noted, we recommend extending \nZend\\View\\Helper\\AbstractHelper\n, as it implements the\nmethods defined in \nHelperInterface\n, giving you a headstart in your development.\n\n\n\n\nInvokable helpers\n\n\nStarting with version 2.7.0, helpers no longer need to be instances of\n\nHelperInterface\n, but can be \nany\n PHP callable. We recommend writing helpers\nas invokable classes (classes implementing \n__invoke()\n.\n\n\n\n\nOnce you have defined your helper class, make sure you can autoload it, and then\nregister it with the \nplugin manager\n.\n\n\nHere is an example helper, which we're titling \"SpecialPurpose\"\n\n\nnamespace MyModule\\View\\Helper;\n\nuse Zend\\View\\Helper\\AbstractHelper;\n\nclass SpecialPurpose extends AbstractHelper\n{\n    protected $count = 0;\n\n    public function __invoke()\n    {\n        $this->count++;\n        $output = sprintf(\"I have seen 'The Jerk' %d time(s).\", $this->count);\n        return htmlspecialchars($output, ENT_QUOTES, 'UTF-8');\n    }\n}\n\n\n\nThen assume that we \nregister it with the plugin manager\n\nby the name \"specialpurpose\".\n\n\nWithin a view script, you can call the \nSpecialPurpose\n helper as many times as\nyou like; it will be instantiated once, and then it persists for the life of\nthat \nPhpRenderer\n instance.\n\n\n// remember, in a view script, $this refers to the Zend\\View\\Renderer\\PhpRenderer instance.\necho $this->specialPurpose();\necho $this->specialPurpose();\necho $this->specialPurpose();\n\n\n\nThe output would look something like this:\n\n\nI have seen 'The Jerk' 1 time(s).\nI have seen 'The Jerk' 2 time(s).\nI have seen 'The Jerk' 3 time(s).\n\n\n\nSometimes you will need access to the calling \nPhpRenderer\n object; for\ninstance, if you need to use the registered encoding, or want to render another\nview script as part of your helper. This is why we define the \nsetView()\n and\n\ngetView()\n methods. As an example, we could rewrite the \nSpecialPurpose\n helper\nas follows to take advantage of the \nEscapeHtml\n helper:\n\n\nnamespace MyModule\\View\\Helper;\n\nuse Zend\\View\\Helper\\AbstractHelper;\n\nclass SpecialPurpose extends AbstractHelper\n{\n    protected $count = 0;\n\n    public function __invoke()\n    {\n        $this->count++;\n        $output  = sprintf(\"I have seen 'The Jerk' %d time(s).\", $this->count);\n        $escaper = $this->getView()->plugin('escapehtml');\n        return $escaper($output);\n    }\n}\n\n\n\n\n\nAccessing the view or other helpers in callables\n\n\nAs noted earlier, starting in version 2.7.0, you may use any PHP callable as a\nhelper. If you do, however, how can you access the renderer or other plugins?\n\n\nThe answer is: dependency injection.\n\n\nIf you write your helper as a class, you can accept dependencies via the\nconstructor or other setter methods. Create a factory that pulls those\ndependencies and injects them.\n\n\nAs an example, if we need the \nescapeHtml()\n helper, we could write our helper\nas follows:\n\n\nnamespace MyModule\\View\\Helper;\n\nuse Zend\\View\\Helper\\EscapeHtml;\n\nclass SpecialPurpose\n{\n    private $count = 0;\n\n    private $escaper;\n\n    public function __construct(EscapeHtml $escaper)\n    {\n        $this->escaper = $escaper;\n    }\n\n    public function __invoke()\n    {\n        $this->count++;\n        $output  = sprintf(\"I have seen 'The Jerk' %d time(s).\", $this->count);\n        $escaper = $this->escaper;\n        return $escaper($output);\n    }\n}\n\n\n\nThen we would write a factory like the following:\n\n\nuse Zend\\ServiceManager\\AbstractPluginManager;\n\nclass SpecialPurposeFactory\n{\n    public function __invoke($container)\n    {\n        if (! $container instanceof AbstractPluginManager) {\n            // zend-servicemanager v3. v2 passes the helper manager directly.\n            $container = $container->get('ViewHelperManager');\n        }\n\n        return new SpecialPurpose($container->get('escapeHtml'));\n    }\n}\n\n\n\nIf access to the view were required, we'd pass the \nPhpRenderer\n service\ninstead.\n\n\n\n\nRegistering Concrete Helpers\n\n\nSometimes it is convenient to instantiate a view helper, and then register it\nwith the renderer.  This can be done by injecting it directly into the plugin\nmanager.\n\n\n// $view is a PhpRenderer instance\n\n$helper = new MyModule\\View\\Helper\\LowerCase;\n// ...do some configuration or dependency injection...\n\n$view->getHelperPluginManager()->setService('lowercase', $helper);\n\n\n\nThe plugin manager will validate the helper/plugin, and if the validation\npasses, the helper/plugin will be registered.",
            "title": "Advanced usage of helpers"
        },
        {
            "location": "/helpers/advanced-usage/#advanced-usage-of-helpers",
            "text": "",
            "title": "Advanced usage of helpers"
        },
        {
            "location": "/helpers/advanced-usage/#registering-helpers",
            "text": "Zend\\View\\Renderer\\PhpRenderer  composes a  plugin manager  for managing\nhelpers, specifically an instance of  Zend\\View\\HelperPluginManager , which\nextends  Zend\\ServiceManager\\AbstractPluginManager , which is itself an\nextension of  Zend\\ServiceManager\\ServiceManager .   HelperPluginManager  is a\nspecialized service manager, so you can register a helper/plugin like any other\nservice (see the  Service Manager documentation \nfor more information).  Programmatically, this is done as follows:  use MyModule\\View\\Helper\\LowerCase;\n\n// $view is an instance of PhpRenderer\n$pluginManager = $view->getHelperPluginManager();\n\n// Register an alias:\n$pluginManager->setAlias('lowercase', LowerCase::class);\n\n// Register a factory:\n$pluginManager->setFactory(LowerCase::class, function () {\n   $lowercaseHelper = new LowerCase();\n\n   // ...do some configuration or dependency injection...\n\n   return $lowercaseHelper;\n});  Within an MVC application, you will typically pass a map of plugins to the class\nvia your configuration.  use MyModule\\View\\Helper;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\n// From within a configuration file\nreturn [\n   'view_helpers' => [\n        'aliases' => [\n            'lowercase' => Helper\\LowerCase::class,\n            'uppercase' => Helper\\UpperCase::class,\n        ],\n        'factories' => [\n            LowerCase::class => InvokableFactory::class,\n            UpperCase::class => InvokableFactory::class,\n        ],\n    ],\n];  If your module class implements  Zend\\ModuleManager\\Feature\\ViewHelperProviderInterface ,\nor just the method  getViewHelperConfig() , you could also do the following\n(it's the same as the previous example).  namespace MyModule;\n\nclass Module\n{\n    public function getViewHelperConfig()\n    {\n        return [\n            'aliases' => [\n                'lowercase' => Helper\\LowerCase::class,\n                'uppercase' => Helper\\UpperCase::class,\n            ],\n            'factories' => [\n                LowerCase::class => InvokableFactory::class,\n                UpperCase::class => InvokableFactory::class,\n            ],\n        ];\n    }\n}  The two latter examples can be done in each module that needs to register\nhelpers with the  PhpRenderer ; however, be aware that another module can\nregister helpers with the same name, so order of modules can impact which helper\nclass will actually be registered!",
            "title": "Registering Helpers"
        },
        {
            "location": "/helpers/advanced-usage/#writing-custom-helpers",
            "text": "Writing custom helpers is easy. We recommend extending Zend\\View\\Helper\\AbstractHelper , but at the minimum, you need only implement\nthe  Zend\\View\\Helper\\HelperInterface  interface:  namespace Zend\\View\\Helper;\n\nuse Zend\\View\\Renderer\\RendererInterface as Renderer;\n\ninterface HelperInterface\n{\n    /**\n     * Set the View object\n     *\n     * @param  Renderer $view\n     * @return HelperInterface\n     */\n    public function setView(Renderer $view);\n\n    /**\n     * Get the View object\n     *\n     * @return Renderer\n     */\n    public function getView();\n}  If you want your helper to be capable of being invoked as if it were a method call of the PhpRenderer , you should also implement an  __invoke()  method within your helper.  As previously noted, we recommend extending  Zend\\View\\Helper\\AbstractHelper , as it implements the\nmethods defined in  HelperInterface , giving you a headstart in your development.",
            "title": "Writing Custom Helpers"
        },
        {
            "location": "/helpers/advanced-usage/#invokable-helpers",
            "text": "Starting with version 2.7.0, helpers no longer need to be instances of HelperInterface , but can be  any  PHP callable. We recommend writing helpers\nas invokable classes (classes implementing  __invoke() .   Once you have defined your helper class, make sure you can autoload it, and then\nregister it with the  plugin manager .  Here is an example helper, which we're titling \"SpecialPurpose\"  namespace MyModule\\View\\Helper;\n\nuse Zend\\View\\Helper\\AbstractHelper;\n\nclass SpecialPurpose extends AbstractHelper\n{\n    protected $count = 0;\n\n    public function __invoke()\n    {\n        $this->count++;\n        $output = sprintf(\"I have seen 'The Jerk' %d time(s).\", $this->count);\n        return htmlspecialchars($output, ENT_QUOTES, 'UTF-8');\n    }\n}  Then assume that we  register it with the plugin manager \nby the name \"specialpurpose\".  Within a view script, you can call the  SpecialPurpose  helper as many times as\nyou like; it will be instantiated once, and then it persists for the life of\nthat  PhpRenderer  instance.  // remember, in a view script, $this refers to the Zend\\View\\Renderer\\PhpRenderer instance.\necho $this->specialPurpose();\necho $this->specialPurpose();\necho $this->specialPurpose();  The output would look something like this:  I have seen 'The Jerk' 1 time(s).\nI have seen 'The Jerk' 2 time(s).\nI have seen 'The Jerk' 3 time(s).  Sometimes you will need access to the calling  PhpRenderer  object; for\ninstance, if you need to use the registered encoding, or want to render another\nview script as part of your helper. This is why we define the  setView()  and getView()  methods. As an example, we could rewrite the  SpecialPurpose  helper\nas follows to take advantage of the  EscapeHtml  helper:  namespace MyModule\\View\\Helper;\n\nuse Zend\\View\\Helper\\AbstractHelper;\n\nclass SpecialPurpose extends AbstractHelper\n{\n    protected $count = 0;\n\n    public function __invoke()\n    {\n        $this->count++;\n        $output  = sprintf(\"I have seen 'The Jerk' %d time(s).\", $this->count);\n        $escaper = $this->getView()->plugin('escapehtml');\n        return $escaper($output);\n    }\n}",
            "title": "Invokable helpers"
        },
        {
            "location": "/helpers/advanced-usage/#accessing-the-view-or-other-helpers-in-callables",
            "text": "As noted earlier, starting in version 2.7.0, you may use any PHP callable as a\nhelper. If you do, however, how can you access the renderer or other plugins?  The answer is: dependency injection.  If you write your helper as a class, you can accept dependencies via the\nconstructor or other setter methods. Create a factory that pulls those\ndependencies and injects them.  As an example, if we need the  escapeHtml()  helper, we could write our helper\nas follows:  namespace MyModule\\View\\Helper;\n\nuse Zend\\View\\Helper\\EscapeHtml;\n\nclass SpecialPurpose\n{\n    private $count = 0;\n\n    private $escaper;\n\n    public function __construct(EscapeHtml $escaper)\n    {\n        $this->escaper = $escaper;\n    }\n\n    public function __invoke()\n    {\n        $this->count++;\n        $output  = sprintf(\"I have seen 'The Jerk' %d time(s).\", $this->count);\n        $escaper = $this->escaper;\n        return $escaper($output);\n    }\n}  Then we would write a factory like the following:  use Zend\\ServiceManager\\AbstractPluginManager;\n\nclass SpecialPurposeFactory\n{\n    public function __invoke($container)\n    {\n        if (! $container instanceof AbstractPluginManager) {\n            // zend-servicemanager v3. v2 passes the helper manager directly.\n            $container = $container->get('ViewHelperManager');\n        }\n\n        return new SpecialPurpose($container->get('escapeHtml'));\n    }\n}  If access to the view were required, we'd pass the  PhpRenderer  service\ninstead.",
            "title": "Accessing the view or other helpers in callables"
        },
        {
            "location": "/helpers/advanced-usage/#registering-concrete-helpers",
            "text": "Sometimes it is convenient to instantiate a view helper, and then register it\nwith the renderer.  This can be done by injecting it directly into the plugin\nmanager.  // $view is a PhpRenderer instance\n\n$helper = new MyModule\\View\\Helper\\LowerCase;\n// ...do some configuration or dependency injection...\n\n$view->getHelperPluginManager()->setService('lowercase', $helper);  The plugin manager will validate the helper/plugin, and if the validation\npasses, the helper/plugin will be registered.",
            "title": "Registering Concrete Helpers"
        }
    ]
}